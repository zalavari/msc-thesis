
% !TeX spellcheck = hu_HU
% !TeX encoding = UTF-8

%----------------------------------------------------------------------------
\chapter{\bevezetes}
%----------------------------------------------------------------------------

Munkámban az \refstruc{chap:optimalization}ben áttekintem az optimalizálás témakörét, definiálom a lineáris illetve kvadratikus programozás fogalmát.
A dolgozat motivációjának hátterében a D-Wave Systems által forgalomba hozott kvantumszámítógépei állnak, melyekről azt állítják, hogy hatékonyan oldanak meg kvadratikus korlátmentes bináris optimalizálási feladatokat, melyek egy nagyon speciális alesete a kvadratikus programozási feladatoknak, bonyolultságelméleti szempontból még mindig NP-nehezek. Így a \refstruc{chap:optimalization} további részeiben ezt a témakört járom körül, definiálom a szükséges fogalmakat, keresem a választ a 
Egészen konkrétan definiálom a QUBO fogalmát (\refstruc{sec:QuadOpt}), elemzem a korlátmentes és korlátos optimalizálási feladatok közötti különbséget, megállapítva, hogy korlátos feladatból gyakorlatban mindig lehet korlátmenteset csinálni, bár ez nem mindig célravezető (\refstruc{sec:constrainedVSunconstrained}).
Végül a fejezet végén kitérek a QUBO specifikus megfontolásokra, annak motivációs hátterére, a D-Wave gépek működési elvére, és a formalizálás nehézségeire illetve korlátaira (\refstruc{sec:QUBOform}). Ezen felül itt definálom még a kvadratizálás, és a változók gráfjának fogalmát, melyekre később is többször visszautalok.

 
A \refstruc{chap:cuts}ben konkrét feladatok felírását nézem meg, több különböző alakban. Az egyik konkrét feladat az élsúlyozott gráfon maximális vágás keresése, melyet a \refstruc{sec:theoryMaxCut}ban fejtek ki. A feladatot röviden elemzem bonyolultsági szempontból, és a jelenleg ismert legjobb approximáció közlése mellett vázolok egy gyors 2-approximációt elérő algoritmust is (\refstruc{sec:theoryMaxCutComb}).
Ezután megadom a probléma felírását lineáris program segítségével, illetve QUBO használatával is (\refstruc{sec:theoryMaxCutLP}, \refstruc{sec:theoryMaxCutQUBO}).

A másik nagy volumenű probléma, melyet górcső alá veszek, az a maximális K-vágás témaköre, mely a sima maximális vágás egy fajta általánosítása (\refstruc{sec:theoryMaxKCut}). Miután definiálom a problémát, és megadom egy lineáris programként való felírását (\refstruc{sec:theoryMaxKCutLP}), általánosítom az egyszerű maximális vágás QUBO alakját, és megfogalmazom ezt a feladatot is ilyen formátumban (\refstruc{sec:QUBOonehot}). Felismerve, hogy a qubit-eket pazarlóan használjuk, mivel a csoportok elkódolását ,,one-hot" módon végezzük, ezért elkészítek egy másik QUBO formulát is ugyanerre a feladatra (\refstruc{sec:QUBObinary}). A kettő felírást ezután összehasonlítom különböző metrikák alapján (pl. legegyszerűbb metrika változók száma), ezzel becslést adva, hogy milyen gyakorlati tapasztalatokat várunk a megoldásuk során (\refstruc{sec:theoryonehotVSbinary}).

A \refstruc{chap:cuts} végén egy kicsit más témakört boncolgatok. A maximális K-vágás felírása során részproblémaként szembesültünk azzal, hogy bizonyos változók közötti logikai összefüggéseket mindig teljesítsünk. Ez a téma messzebb mutat, így végül egy teljes alfejezetté nőtte ki magát (\refstruc{sec:theoryLogicalGates}), melyben arra keresem a választ, hogy szokásos logikai függvényeket, vagyis logikai kapukat miként tudunk átvinni QUBO alakra. Az egészen egyszerű kapuk viszonylag könnyen mennek \refstruc{sec:theoryElementaryGates}, de például a XOR kaput nem lehet segédváltozó nélkül megvalósítani, melyet a \refstruc{sec:XORgate}ban be is bizonyítok. Hasonlóan közlök egy bizonyítás, hogy nem lehet kettőnél több bemenetű OR kaput segédváltozó használata nélkül létrehozni, egészen pontosan a 3 bemenetes OR kapuhoz legalább 2 segédváltozóra van szükségünk, mellyel viszont a feladat meg is oldható. Ezzel kapcsolatos bizonyítások a \refstruc{sec:MORgate}ban kaptak helyet.

A dolgozat \refstruc{chap:practice}e a gyakorlati eredményekre és tapasztalatokra fókuszál, amelyben összehasonlítom a különböző lehetőségekből adódó módszereket azok eredményessége és hatékonysága alapján.
A QUBO-k optimalizálásához főként a D-Wave Ocean nevű programcsomagját használtam fel, mely több lehetőséget kínál a formulák megoldására (\refstruc{sec:practiceDWave}). A klasszikus megoldók mellett lehetőség van például valódi, a D-Wave Systems által forgalmazott kvantumszámítógépeket is használni, vagy a klasszikus és kvantum eljárásokat hibrid módon ötvözni.
Egy másik, szintén kereskedelmi forgalomban lévő megoldószoftver, amely alkalmas lehet a QUBO-k megoldására Gurobi, mely teljesen a klasszikus, heurisztikus irányt képviseli (\refstruc{sec:Gurobi}). Megvizsgáltam más megoldószoftvereket is, de egyelőre ezeket még nem sikerült a célnak megfelelően felkonfigurálni (\refstruc{sec:practiceOthers}).

A \refstruc{sec:graphGeneration}ban lefektetem az alapjait, hogy milyen tesztbemeneteket generáltam a megoldó szoftverek számára, majd a további részekben grafikonokkal és táblázatokkal elemeztem a tapasztalati eredményeket, melyekben természetesen a legnagyobb hangsúlyt a futásidő, és a kapott eredmény optimalitása kapta.

A munka jelentős részét tette ki számos tapasztalat gyűjtése a D-Wave-es programcsomaggal kapcsolatban, hiszen a terület újdonságából kifolyólag az elérhető dokumentációk meglehetősen limitáltnak bizonyultak.