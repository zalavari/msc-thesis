% !TeX spellcheck = hu_HU
% !TeX encoding = UTF-8

%----------------------------------------------------------------------------
\chapter{\bevezetes}
%----------------------------------------------------------------------------

A dolgozat motivációjának hátterében a D-Wave Systems által forgalomba hozott kvantumszámítógépek állnak, melyekről azt állítják,hogy hatékonyan oldanak meg kvadratikus korlátmentes bináris optimalizálási (QUBO) feladatokat \cite{DWaveSystem}. Ezek nagyon speciális esetei a kvadratikus programozási feladatoknak, de bonyolultságelméleti szempontból még mindig NP-nehezek.

QUBO segítségével viszonylag természetesen felírhatók különböző problémák, mint például a maximális vágás, mely közismerten NP-nehéz probléma. Ugyanakkor gyakorlati szempontból fontos, hiszen például a tipikus klaszterezési problémák megfogalmazhatók így, ha az adatot gráfként tudjuk reprezentálni, illetve rengeteg más alkalmazási terület mellett nagy jelentősége van például a VLSI huzalozásban \cite{wiki:VLSI}\cite{wiki:Maximum_cut}.

Dolgozatomban arra keresem a választ, hogy vajon az új technológiák mennyivel tették könnyebbé különböző problémák formalizálását és megoldását mind elméleti, mind gyakorlati síkon, valóban segíti-e a D-Wave rendszere bizonyos NP-nehéz optimalizálási problémák megoldását. Bár a létrehozható qubitek száma manapság még rendkívül limitált, így is érdekes kérdés, hogy kis bemenetekre látszik-e valami biztató eredmény, illetve a nagy bemenetekkel miképpen birkózik meg akár egy kvantum alapokon működő, akár egy klasszikus optimalizáló.

Munkámban az \refstruc{chap:optimalization}ben röviden áttekintem az optimalizálás témakörét definiálva a lineáris illetve kvadratikus programozás fogalmát, majd konkrétan bevezetem a QUBO fogalmát (\refstruc{sec:QuadOpt}) is. Elemzem a korlátmentes és korlátos optimalizálási feladatok közötti különbséget, megállapítva, hogy korlátos feladatból gyakorlatban mindig lehet korlátmenteset csinálni, noha ez nem mindig célravezető (\refstruc{sec:constrainedVSunconstrained}).
Végül a fejezet végén kitérek a QUBO-specifikus megfontolásokra, annak motivációs hátterére, a D-Wave gépek működési elvére, és a formalizálás nehézségeire illetve korlátaira (\refstruc{sec:QUBOform}). Ezen felül itt definálom még a kvadratizálás, és a változók gráfjának fogalmát, melyekre később is többször visszautalok.

 
A \refstruc{chap:cuts}ben konkrét feladatok felírását nézem meg, több különböző alakban. Az egyik konkrét feladat az élsúlyozott gráfon maximális vágás keresése, melyet a \refstruc{sec:theoryMaxCut}ban fejtek ki. A feladatot röviden elemzem bonyolultsági szempontból, és vázolok egy gyors 2-approximációt elérő, polinom idejű algoritmust is (\refstruc{sec:theoryMaxCutComb}).
Ezután megadom a probléma felírását lineáris program segítségével, illetve QUBO használatával is (\refstruc{sec:theoryMaxCutLP}, \refstruc{sec:theoryMaxCutQUBO}).

A másik nagy volumenű probléma, melyet górcső alá veszek, az a maximális K-vágás témaköre, mely a sima maximális vágás egy fajta általánosítása (\refstruc{sec:theoryMaxKCut}). Miután definiálom a problémát, és megadom egy lineáris programként való felírását (\refstruc{sec:theoryMaxKCutLP}), általánosítom az egyszerű maximális vágás QUBO alakját, és megfogalmazom ezt a feladatot is ilyen formátumban (\refstruc{sec:QUBOonehot}). Felismerve, hogy a qubiteket pazarlóan használjuk, olyan értelemben, hogy a csoportok elkódolását ,,one-hot" módon végezzük. Bizonyos feladatokban segíthet, ha inkább tömörebb bináris felírásban kódolva tároljuk a számokat, ezért elkészítek egy másik QUBO formulát is ugyanerre a feladatra (\refstruc{sec:QUBObinary}), bár itt sajnos egyéb segédváltozók bevezetésére is lesz szükségem. A kettő felírást ezután összehasonlítom különböző metrikák alapján (pl. legegyszerűbb metrika változók száma), ezzel becslést adva, hogy milyen gyakorlati tapasztalatokat várunk a megoldásuk során (\refstruc{sec:theoryonehotVSbinary}).

A \refstruc{chap:cuts} végén egy kicsit más témakört boncolgatok. A maximális K-vágás felírása során részproblémaként szembesültünk azzal, hogy bizonyos változók közötti logikai összefüggéseket teljesítsünk. Ez a téma messzebb mutat, így végül egy teljes alfejezetté nőtte ki magát (\refstruc{sec:theoryLogicalGates}), melyben arra keresem a választ, hogy szokásos logikai függvényeket, vagyis logikai kapukat miként tudunk átvinni QUBO alakra. Az, hogy az egészen egyszerű kapuk viszonylag könnyen megvalósíthatók ismert tény, -- bár forrást nem találtam, ahol ezt összefoglalóan meg is mutatják, -- hiszen viszonylag rövid számolás után kijönnek, de ezeket nekem is sikerült levezetnem a \refstruc{sec:theoryElementaryGates}ban. Ezzel szemben például a XOR kaput nem lehet segédváltozó nélkül megvalósítani, amelyre viszont egyáltalán nem találtam korábbi eredményt, így egy teljesen saját bizonyítást közlök rá a \refstruc{sec:XORgate}ban. Hasonlóan módszerrel bizonyítom azt is, hogy nem lehet kettőnél több bemenetű OR kaput segédváltozó használata nélkül QUBO-val implementálni, egészen pontosan a 3 bemenetes OR kapuhoz legalább 2 segédváltozóra van szükségünk, mellyel viszont a feladat meg is oldható. Ezzel kapcsolatos bizonyítások a \refstruc{sec:MORgate}ban kaptak helyet.

A dolgozat \refstruc{chap:practice}e a gyakorlati eredményekre és tapasztalatokra fókuszál, amelyben összehasonlítom a különböző lehetőségekből adódó módszereket azok eredményessége és hatékonysága alapján.
A QUBO-k optimalizálásához főként a D-Wave Ocean nevű programcsomagját használtam fel, mely több lehetőséget kínál a formulák megoldására (\refstruc{sec:practiceDwave}). A klasszikus megoldók mellett lehetőség van például valódi, a D-Wave Systems által forgalmazott kvantumszámítógépeket is használni, vagy a klasszikus és kvantum eljárásokat hibrid módon ötvözni.
Egy másik, szintén kereskedelmi forgalomban lévő megoldószoftver, amely alkalmas lehet a QUBO-k megoldására a Gurobi, mely teljesen a klasszikus, heurisztikus irányt képviseli (\refstruc{sec:Gurobi}). Megvizsgáltam más megoldószoftvereket is, de egyelőre ezeket még nem sikerült a célnak megfelelően felkonfigurálni (\refstruc{sec:practiceOthers}).

A \refstruc{sec:graphGeneration}ban lefektetem az alapjait, hogy milyen tesztbemeneteket generáltam a megoldó szoftverek számára, majd a további részekben grafikonokkal és táblázatokkal elemeztem a tapasztalati eredményeket, melyekben természetesen a legnagyobb hangsúlyt a futásidő, és a kapott eredmény optimalitása kapta.

A munka jelentős részét tette ki számos tapasztalat gyűjtése a D-Wave-es programcsomaggal kapcsolatban, hiszen a terület újdonságából kifolyólag az elérhető dokumentációk meglehetősen limitáltnak bizonyultak.