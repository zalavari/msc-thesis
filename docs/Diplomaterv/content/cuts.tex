% !TeX spellcheck = hu_HU
% !TeX encoding = UTF-8

%----------------------------------------------------------------------------
\chapter{Problémák formalizálása}\label{chap:cuts}
%----------------------------------------------------------------------------


Ebben a fejezetben különböző vágási problémákat tekintek, különös tekintettel a maximális, és a maximális-K-vágásra, illetve megvizsgálom, hogy miként fogalmazhatók meg valamilyen optimalizációs programként. Az egyik ötlet megvalósításához szükség van logikai kifejezések QUBO-ként való felírására is, ezért erre még egy teljes külön alfejezetet szánok a fejezet végén.

Ha máshogy nem jelzem, a továbbiak $G=(V,E)$ jelöljön egy gráfot, ahol szokásos módon $n=|V|$ és $m=|E|$. A gráf élei legyenek súlyozva nem negatív valós számokkal, ahol az $uv \in E$ súlya $w_{uv}$.

Jelölje továbbá $[k]$ az 1-től $k$-ig tartó egészek halmazát. $inf$ pedig egy elegendően nagy számkonstanst jelöljön.

TODO: Az $inf$-et a jövőben inkább kicserélném $P$-re.

%%----------------------------------------------------------------------------
%\section{Minimális vágás}
%%----------------------------------------------------------------------------
%
%\subsection{Kombinatorikus megoldással}
%
%Kombinatorikusan is "könnyen" megoldható feladat. Ha ismerünk két csúcsot $s, t$, melyeknek külön részbe kell kerülniük, akkor a feladat megoldható a jól ismert max-folyamot előállító algoritmussal. (Amennyiben nem ismerünk két ilyen csúcsot, akkor a gráf egy $s$ csúcsát fixálhatjuk, és az algoritmust lefuttatjuk minden $st$ párra.)
%
%\subsection{Lineáris programozással}
%%A probléma természetes módon felírható IP formában.
%%Sőt, belátható, hogy amennyiben a súlyok egészek, a relaxált feladatból is kinyerhető egy optimális megoldás. (Azt hiszem, még utána kell nézni.)
%
%\subsection{QUBO}
%
%A feladat felírható QUBO formában is. Az ötlet, hogy minden csúcsot jelöljünk egy $x_i$ bináris változóval, amelynek értéke mutatja, hogy az $i.$ csúcs melyik csoportba tartozik. A célfüggvényt úgy konstruáljuk, hogy egy él súlyát csak akkor számoljuk bele az összegbe, ha az a két csoport közt fut, és ezt az összeget szeretnénk minimalizálni.
%
%Ekkor persze a minimum az a triviális megoldás lenne, hogy minden csúcsot egy csoportba osztunk be. Vagyis azt kell elérni még, hogy egyik csoport sem üres.
%Ezt tudjuk kezelni, csakúgy mint a kombinatorikus esetben, azaz tegyük fel, hogy tudjuk egy $s$, $t$ csúcspárról, hogy nekik külön kell kerülniük. (Ha ezt nem tudjuk, akkor $s$ fixálásával $(n-1)$-szer kell futtassuk a megoldó algoritmust.)
%Ha $s$ és $t$ külön csoportba kell kerüljön, akkor feltehetjük, hogy $x_s=0$ és $x_t=1$. Vezessünk be büntető tagokat a célfüggvénybe, hogy ezt mindenképpen kikényszerítsük. (Megjegyzés: lényegtelen, hogy a változókra direkt módon, vagy a változók négyzetére szabjuk a büntetést.)
%
%\begin{align}
%	\min_{x} \left\{ \sum_ {\{i,j\}\in E(G)}{w_{ij}\cdot(x_i-x_j)^2} + x_s\cdot inf + (1-x_t)\cdot inf \right\}
%\end{align}


%----------------------------------------------------------------------------
\section{Maximális vágás}\label{sec:theoryMaxCut}
%----------------------------------------------------------------------------

A maximálás vágás problémája arra keresi a választ, hogy (élsúlyozott) $G$ gráfban miként lehet szétosztani a csúcsokat két halmazra, aszerint, hogy azon élek összsúlya, amelyek végpontjai különböző halmazokba kerültek, maximális legyen. A problémának több változata is ismert és kutatott, ennek a dolgozatnak a keretében a pozitív valós élsúlyokkal ellátott esetet vizsgáljuk, amely kellően általános. Ennek nagyon speciális esete, ha minden élsúly $1$ értékű, hiszen ekkor elég az elvágott élek számára maximalizálni. Ezt a problémát ismerhetjük még maximális páros részgráf néven is, amely, bár az általános problémánál sokkal speciálisabb, még mindig NP-nehéz annak az eldöntése is, hogy adott gráfban létezik-e, $e$ élű páros részgráf.

\subsection{Kombinatorikus megoldás}\label{sec:theoryMaxCutComb}

Polinom idejű algoritmust sajnos nem várhatunk, mivel a feladat egy a leghíresebb NP-nehéz problémák közül. Természetesen exponenciális futásidejű algoritmus adható, hiszen a gráf csúcsait összesen $2^{n-1}$ féleképpen lehet szétválasztani két csoportra, egy vágás súlyának kiszámítása, pedig lineáris idejű a bemenet méretének függvényében. Ezzel így adódok egy $O(m 2^n)$ lépésszámú algoritmus.

Ha gyors algoritmust szeretnénk, akkor a pontos optimum helyett egy közel optimális megoldást célszerű keresni. Szerencsére ilyen létezik is. 2-approximációt viszonylag gyors és egyszerű algoritmus segítségével lehet már adni, például úgy, hogy a csúcsokat egyesével kiválasztva döntünk, hogy melyik csoportba osszuk be őket, aszerint, hogy az aktuálisan kiválasztott csúcsból kiinduló élek összsúlyának nagyobb része menjen a másik csoportba. Ezzel elértük, hogy minden bekerülő csúcsnál legalább annyi élsúly lesz a két csoport között, mint a csoportokon belül. Mivel tudjuk, hogy az optimum legfeljebb az élek összsúlya lehet, és ez a megoldás legalább az összsúly felét kiválasztja, ezért ez egy (legrosszabb esetben is) 2-approximáció\footnote{Itt nem bizonyítjuk, de valójában létezik rá éles példa, így az approximációs faktora nem jobb 2-nél.}.

Viszont az is korábbról ismert tény, hogy (amennyiben $\text{P} \neq \text{NP}$) nem létezik rá polinomiális approximációs séma. A legjobb eddig ismert közelítés approximációs faktora körülbelül $1.139$, amely egyébként a dolgozatom témájához is közel eső szemidefinit programozással lett először elérhető, sőt amennyiben a Unique Games sejtés igaz, bizonyított, hogy ennél jobb nem is létezik. TODO: forrás

A problémának ismert felírása egészértékű- illetve kvadratikus programozással is, melyeket a következő alfejezetekben vizsgálok.

\subsection{Lineáris programozással}\label{sec:theoryMaxCutLP}

Egész értékű lineáris programozási feladat felírható rá, minden $\{i,j\} \in E(G)$ élre (pontosabban később látjuk majd, hogy minden csúcspárra) vezetünk be egy $d_{ij}$ bináris változót, melynek értéke akkor 1, ha az él benne van a vágásban. Ekkor a célfüggvényben világos, hogy azon élekre adjuk össze a súlyokat, melyek benne vannak a vágásban, és ezt szeretnénk maximalizálni.

\begin{align}
	\max_{d} \left\{ \sum_{\{i,j\}\in E(G)}{w_{ij} \, d_{ij}}\right\}
\end{align}

További korlátokat is fel kell vegyünk, különben a maximum akkor áll elő, ha a változók azonosan 1 értéket vesznek fel.
Amit ki szeretnénk fejezni további korlátokkal, hogy bármely háromszögből pontosan nulla vagy kettő él lehet benne a vágásban. Ez nyilvánvalóan egy szükséges feltétele egy helyes vágásnak, viszont az elégségesség is következik, ha a gráf teljes. Ehhez viszont nem létező éleket kell hozzávegyünk a gráfhoz (és így a változók száma is $\binom{n}{2}$ -re növekszik.) Az élsúlyokat ekkor persze úgy kell megválasszuk, hogy ne zavarják a maximális vágást, (például ha az élsúlyok nemnegatívak, akkor az azonos 0 választás megfelelő) de általában még az sem probléma, ha nem rendelünk az új élekhez explicit súlyokat, hiszen elég ha a célfüggvényben csak az eredeti élekre összegezzük a súlyokat.

\begin{align}
 d_{ij} \leq d_{ik}+d_{kj}  \\
 d_{ij}+d_{ik}+d_{kj} \leq 2  
\end{align}

Érdemes pár szót ejteni a relaxált, azaz az egészértékűségi kényszerek elhagyása után kapott feladatról. Ekkor egy lineáris programot kapunk, amely hatékonyabban megoldható, viszont a változók értékeit a végén még kerekíteni kell, hogy egészértékű megoldást kapjunk. Ezzel a módszerrel ismét egy 2-közelítő algoritmust kapunk. Ez persze egyáltalán nem biztos, hogy gyakorlatban is hasznos, hiszen ahogyan korábban említettem, egyszerű mohó algoritmussal is elérhető a 2-approximáció \cite{10.5555/1283383.1283390, POLJAK1994191}.
Ugyanakkor, ahogyan azt is már kiemeltem, a legjobb ismert közelítést mégis pont egy ehhez nagyon hasonló módszer, a szemidefinit programozás adja. TODO: forrás.


\subsection{QUBO}\label{sec:theoryMaxCutQUBO}

QUBO-val a feladat természetesen módon felírható. Az élekre (csúcspárokra) felírt változók helyett, azonban csak a csúcsokra definiáljuk a bináris változóinkat, és ezek kvadratikus polinomjaikból állnak majd össze az élekre kikövetkeztetett változók. Tehát az ötlet, hogy minden csúcsot jelöljünk egy $x_i$ bináris változóval, amelynek értéke mutatja, hogy az $i.$ csúcs melyik csoportba tartozik. A célfüggvényt úgy konstruáljuk, hogy egy él súlyát csak akkor számoljuk bele az összegbe, ha az a két csoport közt fut, és ezt az összeget szeretnénk maximalizálni.
%Csakúgy, mint a minimális vágás QUBO-ként felírt alakjában, annyi különbséggel, hogy ezúttal maximalizálni szeretnénk. Sőt, a helyzetünk ezúttal sokkal könnyebb, hiszen nincsenek elfajuló esetek, melyek esetén beállna a maximum, illetve további korlátok felvételére, így büntető tagok hozzávételére sincs szükség.

\begin{align}
	\max_{x} \left\{ \sum_{\{i,j\} \in E(G)}{w_{ij} \, (x_i-x_j)^2}\right\}
\end{align}

Ugyanez a négyzetes részt kibontva a következőképpen alakul. Ne felejtsük, hogy mivel változóink binárisak, ezért bármely változó azonos saját maga négyzetével. ($x \in \mathbb{B} \Rightarrow x = x^2$)

\begin{align}
	\max_{x} \left\{ \sum_{\{i,j\} \in E(G)}{w_{ij} \, (x_i+x_j-2 x_i x_j)}\right\}
\end{align}


%----------------------------------------------------------------------------
\section{Maximális K-vágás}\label{sec:theoryMaxKCut}
%----------------------------------------------------------------------------

A maximális K-vágás, vagy max-K-vágás problémája arra keresi a választ, hogy miként tudjuk a gráf csúcsait K részre szétosztani, aszerint hogy azon élek összsúlya, melyek a csoportok között mennek, maximális legyen. Ez a probléma nyilvánvalóan egy általánosítása a sima maximális vágásénak, hiszen a $K=2$ speciális esetben pontosan egyenértékű a két feladat. Ezáltal az is világos, hogy mivel már a $K=2$ speciális eset is NP-nehéz, ezért az általános eset is legalább ennyire bonyolult.
A probléma ismert még más neveken is, egy másik elterjedt megnevezés, a minimum K-partíció, mely azt fejezi ki, hogy a részeken belül futó élek összsúlya legyen minimális. Ezt természetesen pontosan akkor fog előfordulni, amikor a partíciók között lévő élek súlya maximális.

\subsection{Kombinatorikus megoldás}\label{sec:theoryMaxKCutComb}
TODO: ???

\subsection{Lineáris programozással}\label{sec:theoryMaxKCutLP}

Az ötlet itt is hasonlít a sima maximális vágáséhoz. Az élekre ezúttal is bevezetünk egy bináris változót, mely azt jelzi, hogy az él két különböző csoport között fut. Vagyis $y_{uv}=1$, akkor és cs
ak akkor, ha $u, v$ él csoportok között fut. Ezen felül viszont azonosítanunk kell minden egyes csúcsot, hogy ő melyik csoportba fog kerülni. Ezeket szintén binárisan kódoljuk $nK$ db változóban, ahol $x_{vi}$ akkor és csak akkor 1, ha a $v.$ csúcs az $i.$ halmazba kerül. 

A célfüggvény egyértelműen elkészíthető, egyszerűen azon élekre kell összeszámolnunk a súlyokat, melyek két különböző csoport között futnak.

A korlátoknál az elsőként felveendő legfontosabb dolog, hogy bármely $v$ pontosan egy csoportba tartozhasson, ezt \aref{sumMaxKCutLPEachNodeInOnePartition} szummával adhatjuk meg.

A további korlátok (\ref{MaxKCutLP1} - \ref{MaxKCutLP3}) pedig azt biztosítják, hogy a változók konzisztensek, azaz $y_{uv}$ valóban csak akkor legyen $1$, amikor $u$ és $v$ különböző csoportba kerülnek.

\begin{align} \max _{y} &\sum _{\{{u,v}\} \in E} w_{uv} \, y_{uv}  \end{align}
\begin{align} &\sum _{i \in [K]} x_{vi} = 1,&v \in V, \label{sumMaxKCutLPEachNodeInOnePartition} \end{align}
\begin{align}&x_{ui} - x_{vi} \le y_{uv},&\{{u,v}\} \in E, \ i\in [K], \label{MaxKCutLP1} \end{align}
\begin{align}&x_{vi} - x_{ui} \le y_{uv},&\{{u,v}\} \in E, \ i\in [K], \end{align}
\begin{align}&x_{ui} + x_{vi} + y_{uv} \le 2,&\{{u,v}\} \in E, \ i\in [K], \label{MaxKCutLP3} \end{align}
\begin{align}&x_{vi} \in \{{0,1}\} ,&v \in V, \ i\in [K],\end{align}
\begin{align}&y_{uv} \in \{{0,1}\} ,&\{{u,v}\} \in E, \label{MaxKCutLP5} \end{align}

Egy ehhez nagyon hasonló (több korlátot igénylő) probléma felírása megtalálható az interneten, részletes indoklással \cite{Hojny2021}, így a dolgozatban nem . 

\subsection{QUBO-val (One-hot encoding)}\label{sec:QUBOonehot}


A maximális vágásnál a QUBO forma segítségével jelentősen le tudtuk csökkenteni a változók számát, hiszen nem kellett az élekre bevezetnünk változókat. Ezt a trükköt próbáljuk meg itt is.
Vagyis a lineáris programhoz hasonlóan, a $x_{vi}$ változókat megtartjuk, az a tény pedig, hogy egy $uv$ él kettő különböző csoport között fut, egyértelműen következik, ha $x_{vi} \, x_{uj}=1$ valamely $i \neq j$ és $u \neq v$-re.

Ez alapján meg is konstruálhatjuk és fel is írhatjuk a maximalizálandó célunkat. (Egyelőre megengedjük további korlátok létezését is.) Világos, hogy minden, csoportok között futó élet pontosan egyszer fogunk megszámolni, mivel minden csúcs pontosan egy csoportnak lehet az eleme.

\begin{align}
	 \max_{x} & \left\{ \sum _{\{{u,v}\} \in E}  \sum _{\{{i,j}\} \in [K]} w_{uv}\,(x_{vi} \, x_{uj}) \right\}
\end{align}

\begin{align}
	\sum _{i \in [K]} x_{vi} = 1, &v \in V
\end {align}

A korlátokat viszont szeretnénk kiiktatni a felírásból, így azokat valamilyen büntető tagként kell hozzáadni a célfüggvényhez. Amit büntetni szeretnénk, azok azok az esetek, amikor egy csúcs két különböző csoportba is bekerül. Amennyiben azt szeretnénk, hogy $K$ darab változóból pontosan $k$ darab legyen egyes, erre általános technika, hogy büntető tagként a $(\sum _{i \in [K]} x_i - k)^2 $ kifejezést kell hozzávennünk a célfüggvényhez, hiszen ennek értéke akkor és csak akkor $0$, ha az $x_i$ változók közül $k$ darab $1$-es, és minden más $0$. Ellenkező esetben a kifejezés értéke valamilyen pozitív szám lesz.

Ezt a módszert is alkalmazhatnánk $k=1$ helyettesítéssel, azonban most egy másik, bár lényegét tekintve hasonló megoldást mutatok. Hiszen azt is mondhatnánk, hogy egy $v$ csúcs pontosan akkor kerül bele két különböző csoportba, ha $x_{vi} \, x_{vj}$ szorzat értéke $1$ valamilyen $i \neq j$-re. Így ezeket az eseteket büntetve a célfüggvényünk kiegészül még \aref{QUBOOnehotonlyone} taggal. 

\begin{align}
	\sum _{v \in V } \sum _{\substack{ i,j \in [K] \\  i \neq j}} (-inf) \, x_{vi} \, x_{vj} \label{QUBOOnehotonlyone}
\end{align}

Fontos megjegyezni, hogy a korábban vázolt általános módszerhez képest, elég a nagyobb esetet büntetni, vagyis amikor legalább 2 változó értéke is 1-es. Hiszen az optimumnál impliciten teljesül, hogy az egy csúcshoz tartozó bináris változók közül legalább az egyik $1$ értéket vesz fel. Mivel ha lenne egy változóbehelyettesítés, melynél egy csúcs nem kerülne bele egyetlen csoportba sem, a belőle kimenő élek nem kerülnének bele a vágásba. Így bármelyik csoportba is kerüljön bele, a célfüggvény értéke biztosan nőni fog.

Így a végső QUBO forma:

\begin{align} 
	\max_{x} & \left\{ \sum _{\{{u,v}\} \in E}  \sum _{\{{i,j}\} \in [K]} w_{uv}(x_{vi}  x_{uj}) + \sum _{v \in V } \sum _{\substack{ i,j \in [K] \\  i \neq j}} (-inf) \, x_{vi} \, x_{vj}\right\} 
\end{align}



\subsection{QUBO-val (Binary encoding)}\label{sec:QUBObinary}

Más megoldást is megpróbáltunk keresni, amellyel a QUBO-t tovább egyszerűsíthetjük, a változók számát csökkenthetjük. Erre egy lehetséges irányzat, hogy azt, hogy a csúcs mely csoportba tartozik nem úgy kódoljuk, hogy minden csoport-csúcs párhoz egy bináris változót rendelünk, és a csúcs csoportját "one-hot" módon kódoljuk, hanem kifinomultabb módon, a csoport sorszámát binárisan kódoljuk le. Ennek előnye lehet, hogy így nem szükséges $n \cdot K$ darab bit, hanem elég volna $n \cdot \log K$, ráadásul a problémás korlátot, amely azért szükséges, hogy biztosítsuk, hogy egy csúcs pontosan egy csoportba kerüljön, ezt impliciten teljesítené. Motivációt ad egy friss kutatás, ahol ezt a módszert sikeresen alkalmazták kvantumgép esetében, bár ezt natív módon tették meg  \cite{fuchs2020efficient}. A mi kérdésünk, hogy vajon ezt meg lehet-e csinálni eggyel magasabb absztrakciós szinten, csupán QUBO felírást használva.

A továbbiakban az egyszerű szemléltetés kedvéért feltesszük, hogy a készítendő csoportok száma valamilyen kettő hatvány, vagyis $K=2^m$, így $\log K$ egész. Ezzel mindig feltehető, hogy minden bit szabadon lehet 0 és 1, mert nem lesznek "tiltott" csoportok. Később kitérek arra az esetre, ha ez nem így volna.

A megoldáshoz elsősorban minden csúcshoz definiálunk kell az ő csoportját tartalmazó változókat. Az $u.$ csúcs csoportját jelölje $x_u$, illetve ennek bináris felírását tekintve, az $x_u$ $i.$ bitjét jelölje $x_{ui}$.

Amire szükségünk van, az egy bináris függvény, amely megmondja, hogy két csúcs különböző csoportba esik-e. Ha igen, akkor természetesen a köztük lévő él súlya hozzá kell adódjon a maximalizálandó célfüggvényhez. Ellenkező esetben viszont figyelmen kívül kell hagyni ezt a súlyt.

\begin{align}
D_{uv} = \text{isDifferent}(x_u,x_v)
\end{align}

\begin{align} 
	\max_{x} & \left\{\sum _{\{u,v\} \in E } D_{uv} \, w_{uv} \right\} 
\end{align}

A $D_{uv}$ meghatározása azonban problémákat vet fel. Első körben megpróbálhatjuk, hogy a korábban látott formulák szerint pontosan meghatározható egyes bitek különbsége, hiszen csak a különbségük négyzetét kell venni. A négyzetek, mint tagok összeadása természetesen adja magát, azonban ekkor egy olyan számot kapunk, amely pontosan meghatározza, hogy hány bitben különbözik a két szám, vagyis a Hamming-távolságot. Nekünk elegendő, ha bármely helyiértéken van különbség, akkor szeretnénk végeredményben $1$-et kapni. Erre a módszer, hogy minden négyzetkülönbséget binárisan negálunk, azaz kivonjuk az értékét $1$-ből. Az így kapott kifejezéseket összeszorozzuk, így ha bárhol volt különbség a szorzat valamely tényezője 0, így természetesen maga a szorzat is 0. Amennyiben sehol nincs különbség, a szorzat minden tagja 1, így a szorzat is. Mivel a $D_{uv}$ definíciója szerint akkor 1, ha a két kettes számrendszerben felírt szám különbözik, ezért még a végén egy plusz negálást kell elvégezni.

\begin{align}	
	D_{uv} = 1-  \left( 1-(x_{u1}-x_{v1})^2 \right) \cdot \left( 1-(x_{u2}-x_{v2})^2 \right) \cdot ...  \cdot \left( 1-(x_{u\log K}-x_{v \log K})^2 \right) 
\end{align}

Az így kapott formula azonban nem kvadratikus, hanem jóval nagyobb, akár $2 \cdot \log K$ is lehet a változók összes kitevője egy tagban. Sőt, ha végiggondoljuk majdnem minden lehetséges változókombináció megjelenik, ha elvégezzük a szorzásokat. (Csak annyi a szabály, hogy ha $x_{ui}$ megjelenik, akkor az vagy a négyzeten szerepel, vagy meg van szorozva $x_{vi}$-vel.)

Kellő számú változó bevezetésével, és azok behelyettesítésével természetesen a formula kvadratikus alakra hozható, ahogyan azt már láttuk a \refstruc{QUBOform}ban, de ez a konkrét esetben nem könnyű feladat. Bár mechanikusan elvégezhető, de nem ismert jó módszer erre a feladatra, amely az újonnan bevezetett változókra és a keletkező kvadratikus tagokra minimalizálna. Így a továbbiakban, bár az eredményként lényegében az előzővel azonos, egy másik szemléletet fogok alkalmazni, amely természetesebben adja, hogy hol és mennyi változó bevezetése szükséges.


Annak jelölésére, hogy az $u$ és $v$ csúcsok különböző csoportokba kerülnek-e, használjuk továbbra is a $D_{uv}$ bináris változót. Két egyedi bit összehasonlítására pedig a $d_{uvi}$ változót definiáljuk, melynek jelentése, hogy az $x_u$ és $x_v$ számok $i.$ bitje különböző. $d_{uvi}$ így a XOR műveletének eredménye $x_{ui}$ és  $x_{vi}$-re alkalmazva.

Mivel két szám pontosan akkor különböző, ha legalább egy helyiértékükön eltérnek, ezért a $D_{uv}$-t érdemes úgy előállítani, hogy minden bit különbözőségét OR kapcsolatba állítjuk.

\begin{align}
	D_{uv} = \bigvee_{i \in [ \log K ] }{d_{uvi}}
\end{align}

\begin{align}
	d_{uvi} = x_{ui} \oplus x_{vi}
\end{align}

Ha feltesszük, hogy a logikai kapuk által definiált relációk megvalósíthatók további változók bevezetése nélkül, akkor kiszámolható egy alsó becslés arra, hogy összesen hány változóra van szükségünk. A csoportok elkódolásához kell $n \log K$ db. Minden csúcspár összehasonlításához kell $\log K + 1$ darab, hiszen minden bitpárhoz kell egy, és végül maga a $D_{uv}$. Így ez összesen $\binom{n}{2} \, ( \log K + 1 ) + n\log K$ változó.

Valamennyit spórolhatunk, ha a gráf ritka, és ezáltal csak azokat a csúcspárokat hasonlítjuk, melyek között fut él. Ekkor ha az élek száma $m$, akkor $m \, ( \log K + 1 ) + n\log K$ változó szükségeltetik.

\subsection{A két felírás összehasonlítása}\label{sec:theoryonehotVSbinary}

A bináris elkódolás módszerével kapott változószám első közelítésre mindenképpen rosszabb, mint a másik felírásban kapott $nK$, hiszen $n$ legalább akkora, de tipikusan jóval nagyobb, mint $K$, így az $\binom{n}{2}$ tényező (vagy az $m$) várhatóan önmagában is nagyobb lesz, mint $nK$.

A valóságban ráadásul sajnos még ennél is több segédváltozó szükségeltetik. Mint ahogyan a \refstruc{sec:XORgate}ban látni fogjuk a XOR kapu megvalósításához egy további segédváltozót igénybe kell venni, és $\log K$ darab bitre alkalmazott OR művelet sem megy egy lépésben, amely kiderül a \refstruc{sec:MORgate}ban. Ez utóbbinál például egymás után láncolt, vagy bináris fában felépített OR kapukkal érhető el a kívánt eredmény, amely további $\log K -1$ változót igényel, bár ebben már benne van maga a $D_{uv}$ is. Ez így minden csúcspárnál $3\log K - 1$ változót jelent, vagyis összesen $\binom{n}{2} \, (3\log K -  1 ) + n \log K$ változóra van szükség.
 
Térjünk át a \refstruc{sec:QUBOform}ban definiált változók gráfjára, és vizsgáljuk a továbbiakban azt.
Itt a maximum fokszám szempontjából is érdemes lehet elemezni az eredményt, azaz egy változó legfeljebb hány másik változóval van kapcsolatban. A segédváltozók fokszáma többnyire kicsi, hiszen csak néhány másikkal állnak kapcsolatban, viszont a csoportot elkódoló változókra ez már nem igaz, hiszen egy $x_{ui}$ változó kapcsolatban lesz a $d_{uvi}$ és $x_{vi}$,  változókkal, minden $v \neq u$-ra. Így ezen változók fokszáma az eredeti gráf csúcsszámának kétszeresével egyenlő. (Valójában ennél még rosszabb a helyzet, mert ahogyan korábban említettem, a XOR kapu implementálásánál bejön még egy segédváltozó, amely miatt a csúcsszám háromszorosa lesz a maximum fokszám.)

%1\\
%\refstruc{QUBOform}
%
%2\\
%\refstruc{sec:QUBOform}
%
%3\\
%\sectref{QUBOform}
%
%4\\
%\secref{QUBOform}
%
%5\\
%\sectref{sec:QUBOform}
%
%6\\
%\secref{sec:QUBOform}
%
%7\\
%\ref{QUBOform}
%
%8\\
%\ref{sec:QUBOform}


 
Az eredeti, \refstruc{sec:QUBOonehot}ban látott felírásnál, legrosszabb esetben, ha teljes a gráfunk, akkor minden változó minden másik változóval kapcsolatba kerül, így ott a változók gráfja, egy $nK$ csúcsú teljes gráf, tehát a maximum fokszám  $nK -1$. Ez bár rosszabb, mint a \refstruc{sec:QUBObinary}ban bináris felírással adott megoldás, ugyanakkor előbbinél egy nagy teljes gráfról beszélhetünk, amíg utóbbinál, megjelennek $n$-nel arányos méretű teljes részgráfok, hiszen minden $x_ui$ kapcsolatban van minden $x_{vi}$-vel, $d_{uvi}$-vel, és még további segédváltozókkal. Ezekből az egymástól független klikkekből $\log K$ darab van, hiszen minden helyiértékre 1 darab ilyen klikk található. Ezek a klikkek ráadásul valami bonyolultabb struktúrán keresztül közvetetten kapcsolódnak egymáshoz, hiszen a $D_uv$ változók összekapcsolják az $u$ illetve $v$ csúcsokhoz tartozó változókat.

Ahogyan a \refstruc{sec:QUBOform}ban röviden bemutattam, egy teljes gráf beágyazásához nagyon sok qubitre van szükségünk, így az a szerencsés, ha a gráf klikkszáma minél kisebb. Bár a klikkszám illetve a maximális fokszám az új felírásunkban valóban kisebb, a rengeteg újonnan bejövő változó, és bonyolult struktúra miatt nem sejtjük, hogy ezzel valóban egyszerűbb lett a probléma gyakorlati szempontból, különösképpen, hogy a klikkszámnál a különbség csak nagy $K$ értékekre lenne megfigyelhető.

A két felírás különbségeit a változók gráfján a \refstruc{tab:diffMaxKCutFormulas} foglalja össze.


\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c r r }
		\toprule
		  & one-hot encoded & binary encoded \\
		\midrule
		Csúcsok száma  & $n K$     & $\binom{n}{2} \, ( \log K + 1 ) + n \log K$ \\
		Élek száma & TODO & TODO \\
		Max-fokszám    & $n K - 1 $ & $3(n-1)$ \\
		Max-klikk      & $n K$     & $3n-2$ \\		
		\bottomrule
	\end{tabular}
	\caption{Max-K-vágás QUBO alakjai}
	\label{tab:diffMaxKCutFormulas}
\end{table}

  

\section{Logikai kapuk megvalósítása}\label{sec:theoryLogicalGates}

A \refstruc{QUBObinary}ban részproblémaként került elő, hogy bizonyos logikai függvényeket szeretnénk megvalósítani QUBO segítségével. Ez viszont egy jóval általánosabb kérdéskörre vezet, mint ahogyan a konkrét példában alkalmaztuk, így a probléma motivációját nem csak ez a feladat adja. Nagyon egyszerű példa, hogy ha fel tudunk írni tetszőleges logikai kifejezést QUBO segítségével, akkor az választ adhat például a kielégíthetőség kérdésére, amely egy közismert NP-teljes probléma\cite{algoritmusokBook}.

Ennek tudatában, a következő részben szeretném áttekinteni a leggyakrabban előforduló logikai kapukat, és hogy azok miként valósíthatók meg QUBO-val. Valójában logikai kapu alatt jelen esetben csupán azt értjük, hogy változók közötti valamilyen reláció mindig teljesüljön. Tehát pl. ha az AND kapu bemenete $x$ és $y$, kimenete pedig $z$, akkor elvárható, hogy az $x \wedge y = z$ logikai kifejezés mindig teljesüljön. Így általános elv, hogy a logikai kapuk megvalósításánál igazából arra törekszünk, hogy a változók helyes konfigurációi mellett egy adott értékű, praktikusan 0-t adó kifejezést konstruáljunk, amíg minden más, nem megengedett változóbehelyettesítés mellett a kifejezés értéke ennél nagyobb legyen. Ekkor minimalizálás esetén biztosak lehetünk, hogy a minimumhely ott van, ahol minden logikai kapunak megfelelő változóbehelyettesítést kapunk. A kifejezést természetes megszorozhatjuk egy kellően nagyra választott konstanssal, így biztosak lehetünk, hogy a büntetés értéke elég nagy lesz.

Ebből következik az is, hogy bármely logikai függvény QUBO alakban történő felírásának helyességérőlkönnyen meggyőződhetünk, ha elkészítjük annak igazságtábláját, minden lehetséges konfigurációra kiszámítjuk a kifejezés értékét, és ellenőrizzük, hogy csak az igaz állítások mellett szerepel 0, minden más esetben pedig egy pozitív szám lesz a kifejezés értéke a behelyettesítés után.

Nyilvánvalóan, ha önmagának ellentmondó kombinációs hálózatot képzünk le így, akkor nem lehet majd minden büntetésként megfogalmazott korlátot teljesíteni, és az optimum sem lesz ennek megfelelő. Tehát a formula ilyen módon alkalmas lehet akár a kielégíthetőség eldöntésére is.

Végül még egyszer hangsúlyozom, itt lényegében arról van szó, hogy változók bizonyos konfigurációt szeretnénk csak megengedni, ezért a logikai kapukra is jobb így tekinteni, és nem mint olyan (áramköri/logikai) elemek vagy függvények, melyeknek adott bemenete(i) és arra adott kimenete(i) van.

\subsection{Elemi kapuk}\label{sec:theoryElementaryGates}

\subsubsection{"Azonos kapu" ($x=y$)}


Első ilyen "kapu" a legtriviálisabb mind közül, az egyenlőség vagy azonosság. (Nem mint eldöntendő logikai kifejezés, hanem mint értékadás.) Igazából nem is kapu, hanem a fizikai interpretációja a vezeték vagy a buffer volna. Azt már láttuk korábban, hogy két bináris változóról hogyan lehet eldönteni, hogy ők különbözőek-e, ehhez csak a különbségük négyzetösszege kell. Természetesen itt is elég ennyi, ekkor a megfelelő büntetőtagot ezzel a kifejezéssel szorozhatjuk. Tehát amennyiben azt szeretnénk elérni, hogy $x$ és $y$ változóink azonos értékkel bírjanak, a következő kifejezést kell használnunk a célfüggvényben. Ne felejtsük, hogy mivel változóink binárisak, ezért bármely változó azonos saját maga négyzetével. ($x \in \mathbb{B} \Rightarrow x = x^2$)

\begin{align}
	(x-y)^2=-2xy+x+y
\end{align}

\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c c c }
		\toprule
		x & y & büntetés \\
		\midrule
		0 & 0 & 0 \\
		0 & 1 & 1 \\
		1 & 0 & 1 \\
		1 & 1 & 0 \\		
		\bottomrule
	\end{tabular}
	\caption{"Azonos" kapu}
	\label{tab:SAMEgate}
\end{table}

\subsubsection{NOT kapu ($x= \neg y$)}

A következő hasonlóan egyszerű eset a nem-egyenlőség esete. Ha azt szeretnénk leírni, hogy az $x$ bináris változó nem egyenlő az $y$ értékével, ez könnyen megkapható az előző esetből, hiszen akkor 1 értéket kaptunk a rossz, és 0-t a jó esetekben, így csak ezt kell logikailag negálnunk. Vagyis a konstans 1-ből kivonni az így kapott kifejezésünket.



\begin{align}
	1-(x-y)^2=1+2xy-x-y
\end{align}

\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c c c }
		\toprule
		x & y & büntetés \\
		\midrule
		0 & 0 & 1 \\
		0 & 1 & 0 \\
		1 & 0 & 0 \\
		1 & 1 & 1 \\		
		\bottomrule
	\end{tabular}
	\caption{NOT kapu}
	\label{tab:NOTgate}
\end{table}



\subsubsection{AND kapu ($x \wedge y = z$)}

Mivel két változóra felírható összefüggéseket az előző két esettel lényegében kimerítettük, hiszen két bináris változó vagy azonos, vagy különböző értéket vesz fel, ezért nézzük meg néhányat a klasszikus értelemben vett logikai kapuk közül, melyeknél általában, (de minden esetben legalább) 3 változó szerepel.


Első ilyen kifejezésünk az AND kaput fogja leírni, vagyis a $z=x \wedge y$ kifejezést. Ellenőrizhető, hogy, amennyiben az $x$ és $y$ változók közül legfeljebb egy értéke $1$, addig a kifejezés $3z$, illet $z$ értékével lesz egyenlő. A kifejezés értéke így természetesen akkor lesz minimális, ha $z=0$. Amennyiben viszont $x=y=1$, akkor a kifejezés $x$ és $y$ behelyettesítése után $1-z$ lesz, mely a minimumhelyét $z=1$ esetben veszi fel.

Fontos megfigyelni azt a korábban kiemelt tényt, hogy itt is lényeges, hogy az érvényes konfigurációknál mind azonos legyen az optimum értéke. Gondolhatnánk, hogy az $xy$ szorzat felesleges a kifejezésben, hiszen lefixált $x$ illetve $y$ értékeknél is igaz a fenti állítás. Azonban ekkor a minimumhely $x=y=z=1$ esetében lenne a legkisebb, tehát a logikai kapu jobban preferálná, ha a bemenetein is 1-esek jelennének meg, amely visszahatna az x és y változók értékeire. Értelemszerűen ezt nem szeretnénk, hiszen ez olyan, mintha egy "bias" lenne beiktatva a logikai kapuba.



\begin{align}
	xy-2(x+y)z+3z
\end{align}

\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c c c c }
		\toprule
		x & y & z & büntetés \\
		\midrule
		0 & 0 & 0 & 0 \\
		0 & 0 & 1 & 3 \\
		0 & 1 & 0 & 0 \\
		0 & 1 & 1 & 1 \\
		1 & 0 & 0 & 0 \\
		1 & 0 & 1 & 1 \\
		1 & 1 & 0 & 1 \\
		1 & 1 & 1 & 0 \\		
		\bottomrule
	\end{tabular}
	\caption{AND kapu}
	\label{tab:ANDgate}
\end{table}

\subsubsection{OR kapu ($x \vee y = z$)}

Az AND kapu mellett a másik alapvető logikai kapu az OR kapu. Ez persze a De Morgan azonosság szerint felírható csupán az AND és a NOT kapu használatával, azonban ez plusz változókat hozna be. Az OR kaput direkt módon is fel tudjuk írni a következő kifejezéssel: 

\begin{align}
	(x+y)+z-2(x+y)z+xy = \\
	x+y+z-2xz-2yz+xy
\end{align}

\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c c c c }
		\toprule
		x & y & z & büntetés \\
		\midrule
		0 & 0 & 0 & 0 \\
		0 & 0 & 1 & 1 \\
		0 & 1 & 0 & 1 \\
		0 & 1 & 1 & 0 \\
		1 & 0 & 0 & 1 \\
		1 & 0 & 1 & 0 \\
		1 & 1 & 0 & 3 \\
		1 & 1 & 1 & 0 \\		
		\bottomrule
	\end{tabular}
	\caption{OR kapu}
	\label{tab:ORgate}
\end{table}

\subsubsection{NOR kapu ($x \vee y = \neg z$)}

A NOR kaput megkaphatjuk az OR kapu kimeneti változójának negálásával, azonban ez plusz egy változót kellene jelentsen. Ehelyett direkt módon próbáljuk meg felírni a kifejezést. Használhatnánk a NOT kapunál látott logikai negálást, azonban amíg ott az kifejezés értékkészlete is bináris volt, ezúttal a kifejezés akár a $3$-at is felveheti értékként. Ennek ellenére a NOR kapu kifejezése majdnem valóban az OR logikai negáltja lesz, csupán az $xy$ szorzat együtthatója változatlan marad.


\begin{align}
	1-(x+y)-z+2(x+y)z+xy = \\
	 1-x-y-z+2xz+2yz+xy
\end{align}

\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c c c c }
		\toprule
		x & y & z & büntetés \\
		\midrule
		0 & 0 & 0 & 1 \\
		0 & 0 & 1 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 1 & 1 & 1 \\
		1 & 0 & 0 & 0 \\
		1 & 0 & 1 & 1 \\
		1 & 1 & 0 & 0 \\
		1 & 1 & 1 & 3 \\		
		\bottomrule
	\end{tabular}
	\caption{NOR kapu}
	\label{tab:NORgate}
\end{table}

\subsubsection{XOR kapu ($x \oplus y = z$)} \label{sec:XORgate}

Ahogyan korábban ez előtérbe került a "két szám bináris felírása különböző-e" kérdéskörben a \refstruc{sec:QUBObinary}ban, nagyon hasznos lenne egy KIZÁRÓ VAGY avagy XOR kapu is. Közismert, hogy csupán az AND és a NOT segítségével is felírható bármely Boole-függvény, így ezek tetszőleges kombinálásával természetesen a XOR is.
Ha megpróbáljuk direkt módon, csupán 3 változó segítségével felírni, problémába ütközünk, mivel ez nem lehetséges. Ezt a tényt alább bizonyítom, mely egyben megad egy általános módszert is hasonló problémák felírására.

Indirekt módon tegyük fel, hogy lehet megfelelő kifejezést alkotni. Legyen ez a kifejezés $A_xx+A_yy+A_zz+A_{xy}xy+A_{xz}xz+A_{yz}yz+C$. Tudjuk, hogy az érvényes változókonfigurációk behelyettesítésére $0$-t, érvénytelen esetben pedig egy $0$-nál nagyobb pozitív számot kell kapjunk. 
(Tekinthetnénk $0$ helyett egy másik fix számot, de a $C$ taghoz hozzáadva az eltolást ezt korrigálhatjuk, illetve ha minimalizálni szeretnénk, akkor elég a kifejezést $-1$-gyel beszorozni.)

Minden változókonfiguráció behelyettesítésével így kapunk egy egyenletet vagy egyenlőtlenséget, melyet az együtthatóknak és a konstans tagnak teljesítenie kell. Az igazságtáblázat 8 sorából keletkező egyenleteket és egyenlőtlenségeket az alábbi táblázat foglalja össze.

\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c c c c l }
		\toprule
		x & y & z & büntetés & egyenlet/egyenlőtlenség \\
		\midrule
		0 & 0 & 0 & $0 $ & $C=0$   \\
		0 & 0 & 1 & $>0$ & $A_{z}+C>0$ \\
		0 & 1 & 0 & $>0$ & $A_{y}+C>0$ \\
		0 & 1 & 1 & $0 $ & $A_{y}+A_{z}+A_{yz}+C=0$   \\
		1 & 0 & 0 & $>0$ & $A_{x}+C>0$ \\
		1 & 0 & 1 & $0 $ & $A_{x}+A_{z}+A_{xz}+C=0$   \\
		1 & 1 & 0 & $0 $ & $A_{x}+A_{y}+A_{xy}+C=0$   \\
		1 & 1 & 1 & $>0$ & $A_{x}+A_{y}+A_{z}+A_{xy}+A_{xz}+A_{yz}+C>0$ \\				
		\bottomrule
	\end{tabular}
	\caption{XOR kapu 3 változóval}
	\label{tab:XORgate3var}
\end{table}

Az első egyenletből látjuk, hogy $C=0$, így a továbbiakban ezt mindenhova behelyettesíthetjük. A 4. 6. és 7. sorokból tudhatjuk, hogy $A_{yz}=-A_y-A_z$, $A_{xz}=-A_x-A_z$ és $A_{xy}=-A_x-A_y$. Ezeket behelyettesítve a 8. sorba, az azonos tagok összevonása után azt kapjuk, hogy $-A_x-A_y-A_z>0$.
Azonban a 2. 3. és 5. sorokból azt tudjuk, hogy $A_x$, $A_y$ és $A_z$ pozitív számok. Tehát ellentettjeik összege csakis negatív lehet, nem pedig pozitív. Ez ellentmondás, tehát nem létezhet ilyen kifejezés sem, mellyel a bizonyítás teljes.

Segédváltozók használatával azonban megoldható a probléma, például az alábbi módon. Elég egyetlen segédváltozót bevezetni, ráadásul ennek a változónak mellékesen szemantikusan is adhatunk értelmet, így mondhatjuk a $t$ segédváltozó jelentése legyen $x \wedge y$.
Ekkor a kifejezésünket megkonstruálhatjuk, hogy már a korábban látott módon megkötjük, hogy $t = x \wedge y$, az $xy-2(x+y)z+3z$ kifejezéssel, ezt a kifejezést aztán egy megfelelően nagy számmal beszorozzuk, hogy amikor a további együtthatókat határozzuk meg, biztosan ne romoljon majd el ez az összefüggés. $-2xy-2(x+y)t+(x+y)+t+4zt$ kifejezés minden esetben $0$-t ad a megfelelő konfigurációkra, és egy pozitív számot a helytelenekre, amennyiben csak azokat az eseteket nézzük, ahol $t = x \wedge  y$ teljesül. Amennyiben a feltétel nem adott, akár $-3$-at is kaphatunk eredményül. Ezért tehát a $t = x \wedge  y$-t kikényszerítő feltételt legalább 4-gyel meg kell szorozzuk, ezáltal a büntető tag értéke minden esetben nagyobb lesz $0$-nál, ha a konfiguráció helytelen. Tehát a végleges kifejezésünk:



\begin{align}
	4(xy-2(x+y)z+3z)+(-2xy-2(x+y)t+(x+y)+t+4zt) = \\
    = 4xy-8z(x+y)+12z-2xy-2(x+y)t+(x+y)+t+4zt = \\
	= (x+y)+t+12z+2xy-2(x+y)t+4zt-8z(x+y)
\end{align}

\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c c c c c }
		\toprule
		x & y & z & t & büntetés \\
		\midrule
		0 & 0 & 0 & 0 & 0 \\
		0 & 0 & 0 & 1 & 12 \\
		0 & 0 & 1 & 0 & 1 \\
		0 & 0 & 1 & 1 & 17 \\
		0 & 1 & 0 & 0 & 1 \\
		0 & 1 & 0 & 1 & 5 \\
		0 & 1 & 1 & 0 & 0 \\
		0 & 1 & 1 & 1 & 8 \\		
		1 & 0 & 0 & 0 & 1 \\
		1 & 0 & 0 & 1 & 5 \\
		1 & 0 & 1 & 0 & 0 \\
		1 & 0 & 1 & 1 & 8 \\
		1 & 1 & 0 & 0 & 4 \\
		1 & 1 & 0 & 1 & 0 \\
		1 & 1 & 1 & 0 & 1 \\
		1 & 1 & 1 & 1 & 1 \\		
		\bottomrule
	\end{tabular}
	\caption{XOR kapu}
	\label{tab:XORgate}
\end{table}

Ezáltal minden alapvető logikai kaput le tudunk írni QUBO alakkal, és a XOR kapu 3 változóval történő felírásának bizonyításánál egy általános módszert is kaptunk további, összetettebb kapuk implementálására, amellett, hogy természetesen az alapszintű kapukból is megkonstruálhatunk tetszőleges kombinációs hálózatot.

\subsection{Összetett kapuk}

\subsubsection{Sokbemenetű OR kapu ($x \vee y \vee z = t$)} \label{sec:MORgate}

A \refstruc{sec:QUBObinary}ban részproblémaként került elő sokbemenetű OR kapu előállítása. Ekkor arra hivatkoztam, hogy ez csak több OR kapu kaszkádosításával érhető el. Az alább közlök egy, az előbb látotthoz hasonló bizonyítást, mely szerint nem létezhet QUBO alakban felírt 3 bemenetű OR kapu, segédváltozó használata nélkül.

Ismét tegyük fel indirekten, hogy létezik ilyen kifejezés, vagyis léteznek olyan együtthatók, melyre a $A_{x}x+A_{y}y+A_{y}y+A_{z}z+ A_{xy}xy+A_{xz}xz+A_{xt}xt+ A_{yz}yz+A_{yt}yt+A_{zt}zt+C$ kifejezés a $t=x \vee y \vee z$ logikai kapcsolat fennállása esetén $0$-t, ellenkező esetben valamilyen pozitív számot kapunk behelyettesítés után.
Mivel $0=0 \vee 0 \vee 0$ igaz, ezért $C=0$, így a továbbiakban ezt a konstans tagot elhagyom.

Érdemes ismét összegyűjteni az egyenleteinket és egyenlőtlenségeinket.

\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c c c c c l }
		\toprule
		x & y & z & t & büntetés & egyenlet/egyenlőtlenség \\
		\midrule
		0 & 0 & 0 & 0 & $0 $ & $(C=0)$  \\
		0 & 0 & 0 & 1 & $>0$ & $A_{t}>0$ \\
		0 & 0 & 1 & 0 & $>0$ & $A_{z}>0$ \\
		0 & 0 & 1 & 1 & $0 $ & $A_{z}+A_{t}+A_{zt}=0$   \\
		0 & 1 & 0 & 0 & $>0$ & $A_{y}>0$ \\
		0 & 1 & 0 & 1 & $0 $ & $A_{y}+A_{t}+A_{yt}=0$   \\
		0 & 1 & 1 & 0 & $>0$ & $A_{y}+A_{z}+A_{yz}>0$   \\
		0 & 1 & 1 & 1 & $0 $ & $A_{y}+A_{z}+A_{t}+A_{yz}+A_{yt}+A_{zt}=0$ \\			
		1 & 0 & 0 & 0 & $>0$ & $A_{x}>0$   \\
		1 & 0 & 0 & 1 & $0 $ & $A_{x}+A_{t}+A_{xt}=0$ \\
		1 & 0 & 1 & 0 & $>0$ & $A_{x}+A_{z}+A_{xz}>0$ \\
		1 & 0 & 1 & 1 & $0 $ & $A_{x}+A_{z}+A_{t}+A_{xz}+A_{xt}+A_{zt}=0$   \\
		1 & 1 & 0 & 0 & $>0$ & $A_{x}+A_{y}+A_{xy}>0$ \\
		1 & 1 & 0 & 1 & $0 $ & $A_{x}+A_{y}+A_{t}+A_{xy}+A_{xt}+A_{yt}=0$   \\
		1 & 1 & 1 & 0 & $>0$ & $A_{x}+A_{y}+A_{z}+A_{xy}+A_{xz}+A_{yz}>0$   \\
		1 & 1 & 1 & 1 & $0 $ & $A_{x}+A_{y}+A_{z}+A_{t}+A_{xy}+A_{xz}+A_{yz}+A_{xt}+A_{yt}+A_{zt}=0$ \\	
		\bottomrule
	\end{tabular}
	\caption{3 bemenetű OR kapu segédváltozó nélkül}
	\label{tab:ORgate3in}
\end{table}

A táblázatban 4. és 6. egyenleteket kivonva a 8.-ból következik az $A_{yz}=A_{t}$ azonosság. Hasonlóan, szimmetria okok miatt is, a 4. 10. 12. egyenletekből következik $A_{xz}=A_{t}$ illetve 6. 10. 14. egyenletekből következik $A_{xy}=A_{t}$.

Ezeket behelyettesítve a 16. egyenletbe $A_{x}+A_{y}+A_{z}+4A_{t}+A_{xt}+A_{yt}+A_{zt}=0$ adódik. Melyből kivonva a 4. 6. és 10. egyenleteket, $A_{t}=0$ következik. Ez persze ellentmondásba kerül a 2. egyenlőtlenséggel, tehát az indirekt feltevésünk hibás, vagyis valóban nem lehet segédváltozó nélkül 3 bemenetű OR kaput definiálni QUBO segítségével.

Azt látjuk tehát, hogy 3 bit OR kapcsolatba állításához szükség van legalább 2 segédváltozóra, melyből egyik az eredmény. Ez el is érhető például úgy, hogy az első két bit-re kiszámítjuk az OR értékét, majd az így kapott segédváltozóra újra alkalmazzuk az OR operátort, így megkapjuk az eredményt. Ez a stratégia természetesen folytatható $k$ darab változóra, így $k$ bemenetű OR felírható $k-1$ segédváltozóval, melybe beleértendő az eredmény bit is. Ebből persze nem következik triviálisan, hogy ez az optimális, azaz $k$ darab bit OR kapcsolatba állításához mindig legalább további $k-1$ segédváltozóra van szükség, de hirtelen úgy tűnik, hogy ennél jobbat nem lehet csinálni.
