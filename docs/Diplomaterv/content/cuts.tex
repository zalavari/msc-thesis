% !TeX spellcheck = hu_HU
% !TeX encoding = UTF-8

%----------------------------------------------------------------------------
\chapter{Problémák formalizálása}\label{chap:cuts}
%----------------------------------------------------------------------------


Ebben a fejezetben különböző vágási problémákat tekintek, különös tekintettel a maximális, és a maximális-K-vágásra, illetve megvizsgálom, hogy miként fogalmazhatók meg valamilyen optimalizációs programként. Az egyik ötlet megvalósításához szükség van logikai kifejezések QUBO-ként való felírására is, ezért erre még egy teljes külön alfejezetet szánok a fejezet végén.

Ha máshogy nem jelzem, a továbbiak $G=(V,E)$ jelöljön egy gráfot, ahol $n=|V|$ és $m=|E|$. A gráf élei legyenek súlyozva nem negatív valós számokkal, ahol az $uv \in E$ súlya $w_{uv}$.

Jelölje továbbá $[k]$ az 1-től $k$-ig tartó egészek halmazát. $P$ pedig egy elegendően nagy számkonstanst jelöljön, amelyet büntetőszorzóként fogok használni.


%----------------------------------------------------------------------------
\section{Minimális vágás}
%----------------------------------------------------------------------------

A minimális vágás problémája arra keresi a választ, hogy (élsúlyozott) $G$ gráfban miként lehet szétosztani a csúcsokat két halmazra, aszerint, hogy azon élek összsúlya, amelyek végpontjai különböző halmazokba kerültek, minimális legyen.

\subsection{Kombinatorikus megoldással}

Ez egy klasszikus, kombinatorikusan is ,,könnyen" megoldható feladat. Ha ismerünk két csúcsot $s, t$, melyeknek külön részbe kell kerülniük, akkor a feladat megoldható a jól ismert maximális folyamot előállító algoritmussal. Amennyiben nem ismerünk két ilyen csúcsot, akkor a gráf egy $s$ csúcsát fixálhatjuk, és az algoritmust lefuttatjuk minden $s-t$ párra.

\subsection{Lineáris programozással}
A probléma közismerten formalizálható lineáris optimalizálási problémaként.
Vegyünk fel változót minden élre $(d_{uv})$ és csúcsra $(x_{u})$. Egy csúcsváltozó legyen 0 ha a vágás szerinti egyik, illetve 1 ha a másik csoportba kerül. Egy élváltozó pedig legyen 1, ha az él benne van a vágásban és 0 egyébként.

Mivel a feladat azon múlik, hogy a vágásban szereplő élek összsúlyát akarjuk minimalizálni, ezért ebből következik a (\ref{mincutlp}) célfüggvény.

\begin{align} 
	\min_{d} \left\{ \sum_ {uv \in E(G)}{w_{uv}\cdot d_{uv}} \right\} \label{mincutlp}
\end{align}

A korlátoknak pedig azt kell biztosítaniuk, hogy ha két csúcs különböző oldalra esik, akkor a köztük futó él változója 1 legyen. Ez megtehető a $d_{uv} \geq x_u - x_v$ illetve $d_{uv} \geq x_v - x_u$ korlátokkal, hiszen, ha $x_u=1$ és $x_v=0$, akkor $d_{uv}$ kényszerűen 1 az első korlát miatt, fordított esetben pedig a második korlát miatt.

Érdemes megfigyelni, hogy a $d_{uv}$ változók 0 létére nem szabunk korlátokat, hiszen mivel a célfüggvényünk minimalizál, ha egy változónak ,,nem kell'' 1-nek lennie, akkor a felírás miatt biztos, hogy kisebb értéket kapunk, hogyha az adott változó értékét inkább 0-ra választjuk.

Hogy elkerüljük azt az elfajuló esetet megoldásként, hogy minden csúcs ugyanazon csoportba tartozzék bele, el kell érnünk, hogy egyik partíció se legyen üres. 

Ezt úgy tudjuk kezelni, mint a kombinatorikus esetben, azaz tegyük fel, hogy tudjuk egy $s$, $t$ csúcspárról, hogy nekik külön kell kerülniük. (Ha ezt nem tudjuk, akkor $s$ fixálásával $(n-1)$-szer kell futtassuk a megoldó algoritmust.)
Ha $s$ és $t$ külön csoportba kell kerüljön, akkor korlátként felvehetjük, hogy $x_s=0$ és $x_t=1$.




%Sőt, belátható, hogy amennyiben a súlyok egészek, a relaxált feladatból is kinyerhető egy optimális megoldás. (Azt hiszem, még utána kell nézni.)

\subsection{QUBO}\label{sec:MinCutQUBO}

A feladat felírható QUBO formában is. Az ötlet annyiban hasonlít a korábbihoz, hogy minden csúcsot jelöljünk egy $x_u$ bináris változóval, amelynek értéke mutatja, hogy az $u.$ csúcs melyik csoportba tartozik. A célfüggvényt úgy konstruáljuk, hogy egy él súlyát csak akkor számoljuk bele az összegbe, ha az a két csoport közt fut, és ezt az összeget szeretnénk minimalizálni. Ehhez szerencsére ezúttal nem kell az élekre is változókat bevezetnünk, hiszen ez kiválható a $(x_u-x_v)^2$ kifejezéssel, mely pontosan akkor 1, ha az $x_u$ különbözik az $x_v$-től.

Ekkor persze a minimum az a triviális megoldás lenne, hogy minden csúcsot egy csoportba osztunk be. Vagyis ismét azt kell még elérni, hogy egyik csoport se legyen üres.
Ismét tegyük fel, hogy egy $s$, $t$ csúcspárról tudjuk, hogy nekik külön kell kerülniük. (Ha ezt nem tudjuk, akkor $s$ fixálásával $(n-1)$-szer kell futtassuk a megoldó algoritmust.)
Ekkor feltehetjük, hogy $x_s=0$ és $x_t=1$.
Vezessünk be büntető tagokat a célfüggvénybe, hogy ezt mindenképpen kikényszerítsük. (Megjegyezzük, hogy lényegtelen, hogy a változókra direkt módon, vagy a változók négyzetére szabjuk a büntetést.)

\begin{align}
	\min_{x} \left\{ \sum_ {uv\in E(G)}{w_{uv}\cdot(x_u-x_v)^2} + x_s\cdot P + (1-x_t)\cdot P \right\}
\end{align}


%----------------------------------------------------------------------------
\section{Maximális vágás}\label{sec:theoryMaxCut}
%----------------------------------------------------------------------------

A maximálás vágás problémája arra keresi a választ, hogy (élsúlyozott) $G$ gráfban miként lehet szétosztani a csúcsokat két halmazra, aszerint, hogy azon élek összsúlya, amelyek végpontjai különböző halmazokba kerültek, maximális legyen. A problémának több változata is ismert és kutatott, ennek a dolgozatnak a keretében a pozitív valós élsúlyokkal ellátott esetet vizsgáljuk, amely kellően általános. Ennek nagyon speciális esete, ha minden élsúly $1$ értékű, hiszen ekkor elég az elvágott élek számára maximalizálni. Ezt a problémát ismerhetjük még maximális páros részgráf néven is, amely, bár az általános problémánál sokkal speciálisabb, még mindig NP-nehéz annak az eldöntése is, hogy adott gráfban létezik-e, $e$ élű páros részgráf.

\subsection{Kombinatorikus megoldás}\label{sec:theoryMaxCutComb}

Polinom idejű algoritmust sajnos nem várhatunk, mivel a feladat egy a leghíresebb NP-nehéz problémák közül. Természetesen exponenciális futásidejű algoritmus adható, hiszen a gráf csúcsait összesen $2^{n-1}$ féleképpen lehet szétválasztani két csoportra, egy vágás súlyának kiszámítása, pedig lineáris idejű a bemenet méretének függvényében. Ezzel így adódok egy $O(m 2^n)$ lépésszámú algoritmus.

Ha gyors algoritmust szeretnénk, akkor a pontos optimum helyett egy közel optimális megoldást célszerű keresni. Szerencsére ilyen létezik is. 2-approximációt viszonylag gyors és egyszerű algoritmus segítségével lehet már adni, például úgy, hogy a csúcsokat egyesével kiválasztva döntünk, hogy melyik csoportba osszuk be őket, aszerint, hogy az aktuálisan kiválasztott csúcsból kiinduló élek összsúlyának nagyobb része menjen a másik csoportba. Ezzel elértük, hogy minden bekerülő csúcsnál legalább annyi élsúly lesz a két csoport között, mint a csoportokon belül. Mivel tudjuk, hogy az optimum legfeljebb az élek összsúlya lehet, és ez a megoldás legalább az összsúly felét kiválasztja, ezért ez egy (legrosszabb esetben is) 2-approximáció\footnote{Itt nem bizonyítjuk, de valójában létezik rá éles példa, így az approximációs faktora nem jobb 2-nél.}.

Viszont az is korábbról ismert tény, hogy (amennyiben $\text{P} \neq \text{NP}$) nem létezik rá polinomiális approximációs séma. A legjobb eddig ismert közelítés approximációs faktora körülbelül $1.139$, amely egyébként a dolgozatom témájához is közel eső szemidefinit programozással lett először elérhető, sőt amennyiben a Unique Games sejtés igaz, bizonyított, hogy ennél jobb nem is létezik \cite{10.1145/227683.227684, wiki:Maximum_cut}.

A problémának ismert felírása egészértékű- illetve kvadratikus programozással is, melyeket a következő alfejezetekben vizsgálok.

\subsection{Lineáris programozással}\label{sec:theoryMaxCutLP}

Egész értékű lineáris programozási feladat felírható rá, minden $uv \in E(G)$ élre (pontosabban később látjuk majd, hogy minden csúcspárra) bevezetünk egy $d_{uv}$ bináris változót, melynek értéke akkor 1, ha az él benne van a vágásban. Ekkor a célfüggvényben világos, hogy azon élekre adjuk össze a súlyokat, melyek benne vannak a vágásban, és ezt szeretnénk maximalizálni.

\begin{align}
	\max_{d} \left\{ \sum_{uv\in E(G)}{w_{uv} \, d_{uv}}\right\}
\end{align}

További korlátokat is fel kell vegyünk, különben a maximum akkor áll elő, ha a változók azonosan 1 értéket vesznek fel.
Amit ki szeretnénk fejezni további korlátokkal, hogy bármely háromszögből pontosan nulla vagy kettő él lehet benne a vágásban. Ez nyilvánvalóan egy szükséges feltétele egy helyes vágásnak, viszont az elégségesség is következik, ha a gráf teljes. Ehhez viszont nem létező éleket kell hozzávegyünk a gráfhoz (és így a változók száma is $\binom{n}{2}$ -re növekszik.) Az élsúlyokat ekkor persze úgy kell megválasszuk, hogy ne zavarják a maximális vágást, (például ha az élsúlyok nem negatívak, akkor az azonos 0 választás megfelelő) de általában még az sem probléma, ha nem rendelünk az új élekhez explicit súlyokat, hiszen elég ha a célfüggvényben csak az eredeti élekre összegezzük a súlyokat.

\begin{align}
 d_{uv} \leq d_{uk}+d_{kv}  \\
 d_{uv}+d_{uk}+d_{kv} \leq 2  
\end{align}

Érdemes pár szót ejteni a relaxált, azaz az egészértékűségi kényszerek elhagyása után kapott feladatról. Ekkor egy lineáris programot kapunk, amely hatékonyabban megoldható, viszont a változók értékeit a végén még kerekíteni kell, hogy egészértékű megoldást kapjunk. Ezzel a módszerrel ismét egy 2-közelítő algoritmust kapunk. Ez persze egyáltalán nem biztos, hogy gyakorlatban is hasznos, hiszen ahogyan korábban említettem, egyszerű mohó algoritmussal is elérhető a 2-approximáció \cite{10.5555/1283383.1283390, POLJAK1994191}.
Ugyanakkor, ahogyan azt is már kiemeltem, a legjobb ismert közelítést mégis pont egy ehhez nagyon hasonló módszer, a szemidefinit programozás adja \cite{10.1145/227683.227684}.


\subsection{QUBO}\label{sec:theoryMaxCutQUBO}

QUBO-val a feladat természetesen módon felírható. Az élekre (csúcspárokra) felírt változók helyett, azonban csak a csúcsokra definiáljuk a bináris változóinkat, és ezek kvadratikus polinomjaikból állnak majd össze az élekre kikövetkeztetett változók. Tehát az ötlet, hogy minden csúcsot jelöljünk egy $x_u$ bináris változóval, amelynek értéke mutatja, hogy az $u.$ csúcs melyik csoportba tartozik. A célfüggvényt úgy konstruáljuk, hogy egy él súlyát csak akkor számoljuk bele az összegbe, ha az a két csoport közt fut, és ezt az összeget szeretnénk maximalizálni.
%Csakúgy, mint a minimális vágás QUBO-ként felírt alakjában, annyi különbséggel, hogy ezúttal maximalizálni szeretnénk. Sőt, a helyzetünk ezúttal sokkal könnyebb, hiszen nincsenek elfajuló esetek, melyek esetén beállna a maximum, illetve további korlátok felvételére, így büntető tagok hozzávételére sincs szükség.

\begin{align}
	\max_{x} \left\{ \sum_{uv \in E(G)}{w_{uv} \, (x_u-x_v)^2}\right\}
\end{align}

Ugyanez a négyzetes részt kibontva a következőképpen alakul. Ne felejtsük, hogy mivel változóink binárisak, ezért bármely változó azonos saját maga négyzetével ($x \in \mathbb{B} \Rightarrow x = x^2$).

\begin{align}
	\max_{x} \left\{ \sum_{uv \in E(G)}{w_{uv} \, (x_u + x_v -2 x_u x_v)}\right\}
\end{align}


%----------------------------------------------------------------------------
\section{Maximális K-vágás}\label{sec:theoryMaxKCut}
%----------------------------------------------------------------------------

A maximális K-vágás, vagy max-K-vágás problémája arra keresi a választ, hogy miként tudjuk a gráf csúcsait K részre szétosztani, aszerint hogy azon élek összsúlya, melyek a csoportok között mennek, maximális legyen. Ez a probléma nyilvánvalóan egy általánosítása a sima maximális vágásénak, hiszen a $K=2$ speciális esetben pontosan egyenértékű a két feladat. Ezáltal az is világos, hogy mivel már a $K=2$ speciális eset is NP-nehéz, ezért az általános eset is legalább ennyire bonyolult.
A probléma ismert még más neveken is, egy másik elterjedt megnevezés, a minimum K-partíció, mely azt fejezi ki, hogy a részeken belül futó élek összsúlya legyen minimális. Ez természetesen pontosan akkor fog előfordulni, amikor a partíciók között lévő élek súlya maximális.

A feladat felírható egészértékű lineáris programmal, mely bemutatása után két különböző QUBO felírást mutatok be rá, melyek különböző megközelítés mentén készültek el.
% \subsection{Kombinatorikus megoldás}\label{sec:theoryMaxKCutComb}

\subsection{Lineáris programozással}\label{sec:theoryMaxKCutLP}

Az ötlet itt is hasonlít a sima maximális vágáséhoz. Az élekre ezúttal is bevezetünk egy bináris változót, mely azt jelzi, hogy az él két különböző csoport között fut. Vagyis $y_{uv}=1$, akkor és csak akkor, ha $uv$ él csoportok között fut. Ezen felül viszont azonosítanunk kell minden egyes csúcsot, hogy ő melyik csoportba fog kerülni. Ezeket szintén binárisan kódoljuk $nK$ db változóban, ahol $x_{vi}$ akkor és csak akkor 1, ha a $v$ csúcs az $i.$ halmazba kerül. 

A célfüggvényben egyszerűen azon élekre kell összeszámolnunk a súlyokat, melyek két különböző csoport között futnak.

A korlátoknál az elsőként felveendő legfontosabb dolog, hogy bármely $v$ pontosan egy csoportba tartozhasson, ezt a (\ref{sumMaxKCutLPEachNodeInOnePartition}) szummával adhatjuk meg.

A további korlátok (\ref{MaxKCutLP1} - \ref{MaxKCutLP3}) pedig azt biztosítják, hogy a változók konzisztensek, azaz $y_{uv}$ valóban csak akkor legyen $1$, amikor $u$ és $v$ különböző csoportba kerülnek.

\begin{align} \max _{y} &\sum _{{uv} \in E} w_{uv} \, y_{uv}  \end{align}
\begin{align} &\sum _{i \in [K]} x_{vi} = 1,&v \in V, \label{sumMaxKCutLPEachNodeInOnePartition} \end{align}
\begin{align}&x_{ui} - x_{vi} \le y_{uv},& uv \in E, \ i\in [K], \label{MaxKCutLP1} \end{align}
\begin{align}&x_{vi} - x_{ui} \le y_{uv},& uv \in E, \ i\in [K], \end{align}
\begin{align}&x_{ui} + x_{vi} + y_{uv} \le 2,& uv \in E, \ i\in [K], \label{MaxKCutLP3} \end{align}
\begin{align}&x_{vi} \in \{{0,1}\} ,&v \in V, \ i\in [K],\end{align}
\begin{align}&y_{uv} \in \{{0,1}\} ,& uv \in E \label{MaxKCutLP5} \end{align}

Egy ehhez nagyon hasonló (több korlátot igénylő) probléma felírása megtalálható az interneten, részletes indoklással \cite{Hojny2021}, a dolgozatban nem megyek bele ennél mélyebben. 

\subsection{QUBO-val (One-hot encoding)}\label{sec:QUBOonehot}


A maximális vágásnál a QUBO forma segítségével jelentősen le tudtuk csökkenteni a változók számát, hiszen nem kellett az élekre bevezetnünk változókat. Ezt a trükköt próbáljuk meg itt is.
Vagyis a lineáris programhoz hasonlóan, a $x_{vi}$ változókat megtartjuk, az a tény pedig, hogy egy $uv$ él kettő különböző csoport között fut, egyértelműen következik, ha $x_{vi} \, x_{uj}=1$ valamely $i \neq j$ és $u \neq v$-re.

Ez alapján meg is konstruálhatjuk és fel is írhatjuk a maximalizálandó célunkat. (Egyelőre megengedjük további korlátok létezését is.) Világos, hogy minden, csoportok között futó élet pontosan egyszer fogunk megszámolni, mivel minden csúcs pontosan egy csoportnak lehet az eleme.

\begin{align}
	 \max_{x} & \left\{ \sum _{uv \in E}  \sum _{ {i,j} \in [K]} w_{uv}\,(x_{vi} \, x_{uj}) \right\}
\end{align}

\begin{align}
	&\sum _{i \in [K]} x_{vi} = 1, &v \in V
\end {align}

A korlátokat viszont szeretnénk kiiktatni a felírásból, így azokat valamilyen büntető tagként kell hozzáadni a célfüggvényhez. Amit büntetni szeretnénk, azok azok az esetek, amikor egy csúcs két különböző csoportba is bekerül. Amennyiben azt szeretnénk, hogy $K$ darab változóból pontosan $k$ darab legyen egyes, erre általános technika, hogy büntető tagként a $(\sum _{i \in [K]} x_i - k)^2 $ kifejezést kell hozzávennünk a célfüggvényhez, hiszen ennek értéke akkor és csak akkor $0$, ha az $x_i$ változók közül $k$ darab $1$-es, és minden más $0$. Ellenkező esetben a kifejezés értéke valamilyen pozitív szám lesz.

Ezt a módszert is alkalmazhatnánk $k=1$ helyettesítéssel, azonban most egy másik, bár lényegét tekintve hasonló megoldást mutatok. Hiszen azt is mondhatnánk, hogy egy $v$ csúcs pontosan akkor kerül bele két különböző csoportba, ha $x_{vi} \, x_{vj}$ szorzat értéke $1$ valamilyen $i \neq j$-re. Így ezeket az eseteket büntetve a célfüggvényünk kiegészül még \aref{QUBOOnehotonlyone} taggal. 

\begin{align}
	\sum _{v \in V } \sum _{\substack{ i,j \in [K] \\  i \neq j}} (-P) \, x_{vi} \, x_{vj} \label{QUBOOnehotonlyone}
\end{align}

Fontos megjegyezni, hogy a korábban vázolt általános módszerhez képest, elég a nagyobb esetet büntetni, vagyis amikor legalább 2 változó értéke is 1-es. Hiszen az optimumnál impliciten teljesül, hogy az egy csúcshoz tartozó bináris változók közül legalább az egyik $1$ értéket vesz fel. Mivel ha lenne egy változóbehelyettesítés, melynél egy csúcs nem kerülne bele egyetlen csoportba sem, a belőle kimenő élek nem kerülnének bele a vágásba. Így azt bármelyik csoportba is tegyük bele, a célfüggvény értéke biztosan nőni fog.

Így kapjuk a \aref{QUBOOnehot} kifejezés szerinti végső QUBO alakot.



\begin{align} 
	\max_{x} & \left\{ \sum _{uv \in E}  \sum _{i,j\in [K]} w_{uv}(x_{vi}  x_{uj}) + \sum _{v \in V } \sum _{\substack{ i,j \in [K] \\  i \neq j}} (-P) \, x_{vi} \, x_{vj}\right\} 
	\label{QUBOOnehot}
\end{align}


\subsection{QUBO-val (Binary encoding)}\label{sec:QUBObinary}

Más megoldást is megpróbáltam keresni, amellyel a QUBO-t tovább egyszerűsíthetjük, a változók számát csökkenthetjük. Erre egy lehetséges irányzat, hogy azt, hogy a csúcs mely csoportba tartozik nem úgy kódoljuk, hogy minden csoport-csúcs párhoz egy bináris változót rendelünk, és a csúcs csoportját ,,one-hot" módon kódoljuk, hanem kifinomultabb módon, a csoport sorszámát binárisan kódoljuk le. Ennek előnye lehet, hogy így nem szükséges $n \cdot K$ darab bit, hanem elég volna $n \cdot \log K$, ráadásul a problémás korlátot, amely azért szükséges, hogy biztosítsuk, hogy egy csúcs pontosan egy csoportba kerüljön, ez impliciten teljesítené. Motivációt ad egy friss kutatás, ahol ezt a módszert sikeresen alkalmazták kvantumgép esetében, bár ezt natív módon tették meg  \cite{fuchs2020efficient}. A mi kérdésünk, hogy vajon ezt meg lehet-e csinálni eggyel magasabb absztrakciós szinten, csupán QUBO felírást használva.

A továbbiakban az egyszerű szemléltetés kedvéért feltesszük, hogy a készítendő csoportok száma valamilyen kettő hatvány, vagyis $K=2^m$, így $\log K$ egész. Ezzel mindig feltehető, hogy minden bit szabadon lehet 0 és 1, mert nem lesznek ,,tiltott" csoportok. Később kitérek arra az esetre, ha ez nem így volna.

A megoldáshoz elsősorban minden csúcshoz definiálunk kell az ő csoportját tartalmazó változókat. Az $u$ csúcs csoportját jelölje $x_u$, illetve ennek bináris felírását tekintve, az $x_u$ $i.$ bitjét jelölje $x_{ui}$.

Amire szükségünk van, az egy bináris függvény, amely megmondja, hogy két csúcs különböző csoportba esik-e. Használjuk erre a $D_{uv}$ jelölést, melyet a (\ref{eq:D_uv_def}) kifejezés szerint definiálhatunk. Ha $D_{uv}=1$, vagyis a két csúcs különböző csoportba esik, akkor természetesen a köztük lévő él súlya hozzá kell adódjon a maximalizálandó célfüggvényhez. Ellenkező esetben viszont figyelmen kívül kell hagyni ezt a súlyt (\ref{D_uv_qubo} kifejezés).

\begin{align}\label{eq:D_uv_def}
D_{uv} = \text{isDifferent}(x_u,x_v)
\end{align}

\begin{align} \label{D_uv_qubo}
	\max_{x} & \left\{\sum _{\{u,v\} \in E } D_{uv} \, w_{uv} \right\} 
\end{align}

A $D_{uv}$ meghatározása azonban problémákat vet fel. Első körben megpróbálhatjuk, hogy a korábban látott formulák szerint pontosan meghatározható egyes bitek különbsége, hiszen csak a különbségük négyzetét kell venni. A négyzetek, mint tagok összeadása természetesen adja magát, azonban ekkor egy olyan számot kapunk, amely pontosan meghatározza, hogy hány bitben különbözik a két szám, vagyis a Hamming-távolságot. Ha a két bináris szám azonos, akkor ez pont meg is felel nekünk, de ha bármely helyiértéken van különbség, akkor szeretnénk végeredményben $1$-et kapni, és nem csak egy pozitív számot. (Ha csak egy tetszőleges pozitív számot használunk $D_{uv}=1$ helyett, akkor ezzel az él súlyát többszörösen beleszámolnánk az eredménybe, amennyiben több helyiértéken van eltérés.) Erre a módszer az lehet, hogy minden négyzetkülönbséget binárisan negálunk, azaz kivonjuk az értékét $1$-ből, és az így kapott kifejezéseket összeszorozzuk, így ha bárhol volt különbség a szorzat valamely tényezője 0, ezért maga a szorzat is 0. Amennyiben sehol nincs különbség, a szorzat minden tagja 1, így maga a szorzat is. Mivel a $D_{uv}$ definíciója szerint akkor 1, ha a két kettes számrendszerben felírt szám különbözik, ezért a végén még egy negálást kell elvégezni (\refstruc{eq:D_uv_poli}).

\begin{align}\label{eq:D_uv_poli}
	D_{uv} = 1-  \left( 1-(x_{u1}-x_{v1})^2 \right) \cdot \left( 1-(x_{u2}-x_{v2})^2 \right) \cdot ...  \cdot \left( 1-(x_{u\log K}-x_{v \log K})^2 \right) 
\end{align}

Az így kapott formula azonban nem kvadratikus, hanem jóval nagyobb, akár $2 \log K$ is lehet a változók összes kitevője egy tagban. Sőt, ha végiggondoljuk majdnem minden lehetséges változókombináció megjelenik, ha elvégezzük a szorzásokat. (Csak annyi a szabály, hogy ha $x_{ui}$ megjelenik, akkor az vagy a négyzeten szerepel, vagy meg van szorozva $x_{vi}$-vel.)

Kellő számú változó bevezetésével, és azok behelyettesítésével természetesen a formula kvadratikus alakra hozható, ahogyan azt már kimondta \az+\refstruc{theorem:kvadratizalhato} is, de ez ettől a konkrét esetben még nem könnyű feladat. Bár mechanikusan elvégezhető, de nem ismert jó módszer erre a feladatra, amely az újonnan bevezetett változókra és a keletkező kvadratikus tagokra minimalizálna. Így a továbbiakban, bár az eredményében lényegében az előzővel azonos, egy másik szemléletet fogok alkalmazni, amely természetesebben adja, hogy hol és mennyi változó bevezetése szükséges.

Annak jelölésére, hogy az $u$ és $v$ csúcsok különböző csoportokba kerülnek-e, használjuk továbbra is a $D_{uv}$ bináris változót. Két egyedi bit összehasonlítására pedig a $d_{uvi}$ változót definiáljuk, melynek jelentése, hogy az $x_u$ és $x_v$ számok $i.$ bitje különböző. $d_{uvi}$ így a XOR műveletének eredménye $x_{ui}$ és  $x_{vi}$-re alkalmazva.

Mivel két szám pontosan akkor különböző, ha legalább egy helyiértékükön eltérnek, ezért a $D_{uv}$-t érdemes úgy előállítani, hogy minden bit különbözőségét OR kapcsolatba állítjuk.

\begin{align}
	D_{uv} = \bigvee_{i \in [ \log K ] }{d_{uvi}}
\end{align}

\begin{align}
	d_{uvi} = x_{ui} \oplus x_{vi}
\end{align}

Ha feltesszük, hogy a logikai kapuk által definiált relációk megvalósíthatók további változók bevezetése nélkül, akkor kiszámolható egy alsó becslés arra, hogy összesen hány változóra van szükségünk. A csoportok elkódolásához kell $n \log K$ db. Minden csúcspár összehasonlításához kell $\log K + 1$ darab, hiszen minden bitpárhoz kell egy, és végül maga a $D_{uv}$. Így ez összesen $\binom{n}{2} \, ( \log K + 1 ) + n\log K$ változó.

Valamennyit spórolhatunk, ha a gráf ritka, és ezáltal csak azokat a csúcspárokat hasonlítjuk, melyek között fut él. Ugyanis ha az élek száma $m$, akkor $m \, ( \log K + 1 ) + n\log K$ változó szükségeltetik.

\subsection{A két felírás összehasonlítása}\label{sec:theoryonehotVSbinary}

A bináris elkódolás módszerével kapott változószám első közelítésre mindenképpen rosszabb, mint a másik felírásban kapott $nK$, hiszen $n$ legalább akkora, de tipikusan jóval nagyobb, mint $K$, így az $\binom{n}{2}$ tényező (vagy az $m$) várhatóan önmagában is nagyobb lesz, mint $nK$.

A valóságban ráadásul sajnos még ennél is több segédváltozó szükségeltetik. Mint ahogyan a \refstruc{sec:XORgate}ban látni fogjuk a XOR kapu megvalósításához egy további segédváltozót igénybe kell venni, és $\log K$ darab bitre alkalmazott OR művelet sem megy egy lépésben, amely kiderül a \refstruc{sec:MORgate}ban. Ez utóbbinál például egymás után láncolt, vagy bináris fában felépített OR kapukkal érhető el a kívánt eredmény, amely további $\log K -1$ változót igényel, bár ebben már benne van maga a $D_{uv}$ is. Ez így minden csúcspárnál $3\log K - 1$ változót jelent, vagyis összesen $\binom{n}{2} \, (3\log K -  1 ) + n \log K$ változóra van szükség.
 
Térjünk át \az+\refstruc{def:valtozokgrafja} szerinti változók gráfjára, és vizsgáljuk a továbbiakban azt.
Itt a maximum fokszám szempontjából is érdemes lehet elemezni az eredményt, azaz egy változó legfeljebb hány másik változóval van kapcsolatban. A segédváltozók fokszáma többnyire kicsi, hiszen csak néhány másikkal állnak kapcsolatban, viszont a csoportot elkódoló változókra ez már nem igaz, hiszen egy $x_{ui}$ változó kapcsolatban lesz a $d_{uvi}$ és $x_{vi}$ változókkal, minden $v \neq u$-ra. Így ezen változók fokszáma az eredeti gráf csúcsszámának közel kétszeresével egyenlő. Sőt, valójában ennél még rosszabb a helyzet, mert ahogyan korábban említettem, a XOR kapu implementálásánál bejön még egy segédváltozó, amely miatt a csúcsszám majdnem háromszorosa lesz a maximum fokszám.

 
Az eredeti, \refstruc{sec:QUBOonehot}ban látott felírásnál, legrosszabb esetben, ha teljes a gráfunk, akkor minden változó minden másik változóval kapcsolatba kerül, így ott a változók gráfja, egy $nK$ csúcsú teljes gráf, tehát a maximum fokszám  $nK -1$. Ez bár rosszabb, mint a \refstruc{sec:QUBObinary}ban bináris felírással adott megoldás, ugyanakkor előbbinél egy nagy teljes gráfról beszélhetünk, amíg utóbbinál, csupán $n$ méretű teljes részgráfok jelennek meg, hiszen minden $x_{ui}$ kapcsolatban van minden $x_{vi}$-vel. Ezekből az egymástól független klikkekből $\log K$ darab van, hiszen minden helyiértékre 1 darab ilyen klikk található. Ezek a klikkek viszont a segédváltozók segítségével valami bonyolultabb struktúrán keresztül közvetetten kapcsolódnak egymáshoz, hiszen a $D_{uv}$ változók összekapcsolják az $u$ illetve $v$ csúcsokhoz tartozó változókat.

Ahogyan \az+\refstruc{sec:QUBOform+ban} leírtakból is következik, egy teljes gráf beágyazásához nagyon sok qubitre van szükségünk, így az a szerencsés, ha a gráf klikkszáma minél kisebb. Bár a klikkszám illetve a maximális fokszám az új felírásunkban valóban kisebb, a rengeteg újonnan bejövő változó, és bonyolult struktúra miatt nem sejthető, hogy ezzel valóban egyszerűbb lett a probléma gyakorlati szempontból, különösképpen, hogy a klikkszámnál a különbség csak nagy $K$ értékekre lenne megfigyelhető.

A két felírás különbségeit a változók gráfján a \refstruc{tab:diffMaxKCutFormulas} foglalja össze.


\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c r r }
		\toprule
		  & one-hot encoded & binary encoded \\
		\midrule
		Csúcsok száma  & $n K$     & $\binom{n}{2} \, ( \log K + 1 ) + n \log K$ \\
%		Élek száma & $mK^2+nK^2$ & $\frac{3}{2}(n-1)n \log K+\binom{n}{2} \, ( \log K - 2 ) $ \\
		Max-fokszám    & $n K - 1 $ & $3(n-1)$ \\
		Max-klikk      & $n K$     & $n$ \\		
		\bottomrule
	\end{tabular}
	\caption{Max-K-vágás QUBO alakjai}
	\label{tab:diffMaxKCutFormulas}
\end{table}  

\section{Logikai kapuk megvalósítása}\label{sec:theoryLogicalGates}

A \refstruc{sec:QUBObinary+ban} részproblémaként került elő, hogy bizonyos logikai kifejezéseket szeretnénk megvalósítani QUBO segítségével. Ez viszont egy jóval általánosabb kérdéskörre vezet, mint ahogyan a konkrét példában alkalmaztuk, így a probléma motivációját nem csak ez a feladat adja. Nagyon egyszerű példa, hogy ha fel tudunk írni tetszőleges logikai kifejezést QUBO segítségével, akkor az választ adhat például a kielégíthetőség kérdésére, amely egy közismert NP-teljes probléma \cite{algoritmusokBook}.

Valójában logikai kapu alatt jelen esetben csupán azt értjük, hogy változók közötti valamilyen reláció mindig teljesüljön. Tehát például ha az AND kapu bemenete $x$ és $y$, kimenete pedig $z$, akkor elvárható, hogy az $x \wedge y = z$ logikai kifejezés mindig teljesüljön. Így általános elv, hogy a logikai kapuk megvalósításánál igazából arra törekszünk, hogy a változók helyes konfigurációi mellett egy adott értékű -- praktikusan 0-t adó -- kifejezést konstruáljunk, amíg minden más, nem megengedett változóbehelyettesítés mellett a kifejezés értéke ennél nagyobb (maximalizálás esetén kisebb) legyen. Ekkor biztosak lehetünk, hogy a minimumhely ott van, ahol a logikai kifejezést kielégítő megfelelő változóbehelyettesítést kapunk. A konstruált kifejezést természetes megszorozhatjuk egy kellően nagyra választott konstanssal, így biztosak lehetünk, hogy a büntetés értéke érvénytelen változókonfiguráció esetén elég nagy lesz.

Kicsit formálisabban, adott $C(\mathbf{x}) : \mathbf{x} \in \mathbb{B}^n$ logikai kifejezéshez keresünk olyan kvadratikus $f(\mathbf{x})$ függvényt, hogy a függvény pontosan azokon a helyeken vegye fel a minimumát, ahol $C$ igazra értékelődik ki. Ezt adja meg formálisan a (\ref{eq:logicalQUBO}) kifejezés.

\begin{align} \label{eq:logicalQUBO}
	C(\mathbf{x}) \Leftrightarrow  \min_{\mathbf{x}} \left\{ f(\mathbf{x}) \right\}
	: f(\mathbf{x})=\mathbf{x}^T A \mathbf{x}
\end{align}

Mivel konstans hozzáadásával az $f$ minimumértéke eltolható, ezért kényelmi okokból fixálhatjuk a minimumot nullában, így  a (\ref{eq:logicalQUBOv2}) kifejezést kapjuk. Világos tehát, hogy a (\ref{eq:logicalQUBOv2}) szerinti $f$ függvény a konstans elhagyása után megfelel a (\ref{eq:logicalQUBO}) szerintinek, de amennyiben az első esetben találtunk egy megfelelő $f$ függvényt, abból alkalmas konstans hozzáadásával kapható egy, a (\ref{eq:logicalQUBOv2}) kifejezést kielégítő $f$ függvény is.

\begin{align} \label{eq:logicalQUBOv2}
	C(\mathbf{x}) \Leftrightarrow  f(\mathbf{x})=0 
	: f(\mathbf{x})=\mathbf{x}^T A \mathbf{x} + const. \geq 0
\end{align}

A továbbiakban a könnyebb hivatkozás kedvéért használjuk a \refstruc{def:kvadFunc}t, mely nevet ad ezen $f$ függvényeknek.

\begin{definition}[Logikai kifejezés segédváltozómentes kvadratikus függvénye]\label{def:kvadFunc}
	Azt mondjuk, hogy egy $C(\mathbf{x})$ \textit{logikai formula segédváltozómentes kvadratikus függvénye} az $f(\mathbf{x})$ függvény, ha teljesíti a (\ref{eq:logicalQUBOv2}) kifejezést, vagyis az $f$ a logikai formula bináris változóin értelmezett, nem-negatív kvadratikus függvény, mely értéke akkor és csak akkor zérus, ha $C(\mathbf{x})$ igaz.	
\end{definition}

Az előbbiekből következik, hogy bármely logikai függvény kvadratikus függvényének helyességéről könnyen meggyőződhetünk, ha elkészítjük annak igazságtábláját, minden lehetséges konfigurációra kiszámítjuk a kifejezés értékét, és ellenőrizzük, hogy csak az igaz állítások mellett szerepel 0, minden más esetben pedig egy pozitív szám lesz a kifejezés értéke a behelyettesítés után.

Nyilvánvalóan, ha önmagának ellentmondó kombinációs hálózatot képzünk le így, akkor nem lehet majd minden büntetésként megfogalmazott korlátot teljesíteni, és az optimum sem lesz ennek megfelelő. Tehát a formula ilyen módon lehet alkalmas a már említett kielégíthetőség eldöntésére is.

Végül még egyszer szeretném hangsúlyozni, hogy mivel változók bizonyos konfigurációit szeretnénk csak megengedni, ezért a logikai kapukra is jobb így tekinteni, és nem mint olyan (áramköri/logikai) elemek vagy függvények, melyeknek adott bemenete(i) és arra adott kimenete(i) van. Ezért fontos a (\ref{eq:logicalQUBO}) kifejezésben is az ,,oda-vissza" irány.

Érdemes megfigyelni, hogy bár nem minden logikai kifejezésnek van segédváltozómentes kvadratikus függvénye, mégis tetszőleges logikai kifejezéshez lehet neki megfelelő QUBO alakot felírni. Ezt mondja ki formálisan az alábbi, \az+\refstruc{def:kvadFunc}nál általánosabb definíció, mely megengedi további segédváltozók hozzátételét is a kvadratikus függvényhez és az azt követő állítás.

\begin{definition}[Logikai kifejezés általánosított kvadratikus függvénye]\label{def:kvadFuncgen}
	Azt mondjuk, hogy egy $C(\mathbf{x})$ \textit{logikai formula általánosított kvadratikus függvénye} az $f(\mathbf{y})$ függvény, ha az $f$ egy bináris változókon értelmezett, nem-negatív kvadratikus függvény, mely értéke akkor és csak akkor zérus, ha $C(\mathbf{x})$ igaz.
\end{definition}



\begin{allitas}
	Tetszőleges logikai kifejezésnek létezik általánosított kvadratikus függvénye
	
	 Bár gyakorlatban nem a legjobb módszer, de elméletileg minden logikai kifejezés átalakítható úgy, hogy csak tagadás és AND műveletetet használjunk fel, hiszen ezek funkcionálisan teljesek. Ezután ez átírható PUBO alakra az $\neg X$-et $(1-X)$-re, az $X \wedge Y$-t $XY$ szorzatra cserélve. (Itt $X$ és $Y$ logikai részkifejezéseket jelöl.) Utolsó lépésként a kapott PUBO-t \az+\refstruc{theorem:kvadratizalhato} szerint kvadratizálhatjuk, így kapjuk a QUBO-t, vagyis a logikai kifejezés általánosított kvadratikus függvényét.
\end{allitas}

 Ez viszont nem feltétlen jelenti azt, hogy bármely tetszőleges logikai kifejezésnek valóban létezik is \refstruc{def:kvadFunc} szerinti segédváltozómentes kvadratikus függvénye, hiszen az előbb vázolt folyamatban jelenhetnek meg új segédváltozók. Sőt, ahogyan például a \refstruc{XORnotexist}ben látjuk, nem biztos, hogy egy logikai kifejezésnek egyáltalán létezik kvadratikus függvénye.


\subsection{Elemi kapuk}\label{sec:theoryElementaryGates}

Ezek ismeretében, a következő részben szeretném áttekinteni a leggyakrabban előforduló logikai kifejezéseket, és hogy azok miként valósíthatók meg QUBO-val, azaz miként írható fel kvadratikus függvényük.

\subsubsection{Azonosság ($x=y$)}

Első ilyen ,,kapu" a legtriviálisabb mind közül, az egyenlőség vagy azonosság. (Nem mint eldöntendő logikai kifejezés, hanem mint értékadás.) Igazából nem is kapu, hanem a fizikai interpretációja a vezeték vagy a buffer volna. 

\begin{allitas}
	Az $x=y$ segédváltozómentes kvadratikus függvénye az $f(x,y)=(x-y)^2=-2xy+x+y$.
	
	Azt már láttuk korábban, hogy két bináris változóról hogyan lehet eldönteni, hogy ők különbözőek-e, ehhez csak a különbségük négyzetösszege kell. Természetesen itt is elég ennyi, ekkor a megfelelő büntetőtagot ezzel a kifejezéssel szorozhatjuk. Tehát amennyiben azt szeretnénk elérni, hogy $x$ és $y$ változóink azonos értékkel bírjanak, a következő kifejezést kell használnunk a célfüggvényben. Ne felejtsük, hogy mivel változóink binárisak, ezért bármely változó azonos saját maga négyzetével ($x \in \mathbb{B} \Rightarrow x = x^2$).	
\end{allitas}
	
	Ellenőrzésként megadhatjuk az igazságtáblázatot is, ahol $f(x,y)$ értékét ellenőrizhetjük, hogy valóban csak az érvényes esetekben kapunk nullát, egyébként pedig valamilyen pozitív számot.
	\begin{table}[ht]
		\footnotesize
		\centering
		\begin{tabular}{ c c c }
			\toprule
			x & y & $f(x,y)$ \\
			\midrule
			0 & 0 & 0 \\
			0 & 1 & 1 \\
			1 & 0 & 1 \\
			1 & 1 & 0 \\		
			\bottomrule
		\end{tabular}
		\caption{,,Azonos kapu"}
		\label{tab:SAMEgate}
	\end{table}	



\begin{align}
	(x-y)^2=-2xy+x+y
\end{align}



\subsubsection{NOT kapu ($x= \neg y$)}

A következő hasonlóan egyszerű eset a nem-egyenlőség esete. Ha azt szeretnénk leírni, hogy az $x$ bináris változó nem egyenlő az $y$ értékével, ez könnyen megkapható az előző esetből, hiszen akkor 1 értéket kaptunk a rossz, és 0-t a jó esetekben, így csak ezt kell logikailag negálnunk. Vagyis a konstans 1-ből kivonni az így kapott kifejezésünket.

\begin{allitas}
	Az $x \neq y$ kvadratikus függvénye a $f(x,y)=1-(x-y)^2=1+2xy-x-y$.
	
	Az azonosságnál kapott függvényt kell negálni, és hozzáadni egyet. Táblázattal itt is meggyőződhetünk a kapott függvény helyességéről.
\end{allitas}

	\begin{table}[ht]
		\footnotesize
		\centering
		\begin{tabular}{ c c c }
			\toprule
			x & y & $f(x,y)$ \\
			\midrule
			0 & 0 & 1 \\
			0 & 1 & 0 \\
			1 & 0 & 0 \\
			1 & 1 & 1 \\		
			\bottomrule
		\end{tabular}
		\caption{NOT kapu}
		\label{tab:NOTgate}
	\end{table}	


\subsubsection{AND kapu ($x \wedge y = z$)}

Mivel két változóra felírható összefüggéseket az előző két esettel lényegében kimerítettük, hiszen két bináris változó vagy azonos, vagy különböző értéket vesz fel, ezért nézzük meg néhányat a klasszikus értelemben vett logikai kapuk közül, melyeknél általában, (de minden esetben legalább) 3 változó szerepel.


Első ilyen kifejezésünk az AND kaput fogja leírni, vagyis a $z=x \wedge y$ kifejezést.
\begin{allitas}
	Az $x \wedge y = z$ kvadratikus függvénye a $f(x,y)=xy-2(x+y)z+3z$.
	
	Ellenőrizhető, hogy, amennyiben az $x$ és $y$ változók közül legfeljebb egy értéke $1$, addig a kifejezés $3z$, illet $z$ értékével lesz egyenlő. A kifejezés értéke így természetesen akkor lesz minimális, ha $z=0$. Amennyiben viszont $x=y=1$, akkor a kifejezés $x$ és $y$ behelyettesítése után $1-z$ lesz, mely a minimumhelyét $z=1$ esetben veszi fel.	
\end{allitas}

Szintén ellenőrizhetjük a kapott kifejezést igazságtábla felírásával. 
\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c c c c }
		\toprule
		x & y & z & $f(x,y,z)$ \\
		\midrule
		0 & 0 & 0 & 0 \\
		0 & 0 & 1 & 3 \\
		0 & 1 & 0 & 0 \\
		0 & 1 & 1 & 1 \\
		1 & 0 & 0 & 0 \\
		1 & 0 & 1 & 1 \\
		1 & 1 & 0 & 1 \\
		1 & 1 & 1 & 0 \\		
		\bottomrule
	\end{tabular}
	\caption{AND kapu}
	\label{tab:ANDgate}
\end{table}


Érdemes megfigyelni azt a korábban kiemelt tényt, hogy mennyire lényeges, hogy az érvényes konfigurációknál mind azonos legyen az optimum értéke. Gondolhatnánk, hogy az $xy$ szorzat felesleges a kifejezésben, hiszen lefixált $x$ illetve $y$ értékeknél is igaz a fenti állítás. Azonban ekkor a minimumhely $x=y=z=1$ esetében lenne a legkisebb, tehát a logikai kapu jobban preferálná, ha a bemenetein is 1-esek jelennének meg, amely visszahatna az x és y változók értékeire. Értelemszerűen ezt nem szeretnénk, hiszen ez olyan, mintha egy ,,bias" lenne beiktatva a logikai kapuba.


\subsubsection{OR kapu ($x \vee y = z$)}

Az AND kapu mellett a másik alapvető logikai kapu az OR kapu. Ez persze a De Morgan azonosság szerint felírható csupán az AND és a NOT kapu használatával, azonban ez plusz változókat hozna be. Az OR kaput direkt módon is fel tudjuk írni a következő állítás szerint. 

\begin{allitas}
	Az $x \vee y = z$ kvadratikus függvénye a 
	\begin{align}
		\begin{split}
			(x+y)+z-2(x+y)z+xy = \\
			x+y+z-2xz-2yz+xy
		\end{split}.
	\end{align}

	Az állítás igazságáról ismét legkönnyebben győződhetünk meg az igazságtábla (\refstruc{tab:ORgate}) felírásával.
\end{allitas}

	\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c c c c }
		\toprule
		x & y & z & $f(x,y,z)$ \\
		\midrule
		0 & 0 & 0 & 0 \\
		0 & 0 & 1 & 1 \\
		0 & 1 & 0 & 1 \\
		0 & 1 & 1 & 0 \\
		1 & 0 & 0 & 1 \\
		1 & 0 & 1 & 0 \\
		1 & 1 & 0 & 3 \\
		1 & 1 & 1 & 0 \\		
		\bottomrule
	\end{tabular}
	\caption{OR kapu}
	\label{tab:ORgate}
\end{table}


\subsubsection{NOR kapu ($x \vee y = \neg z$)}

A NOR kaput megkaphatjuk az OR kapu kimeneti változójának negálásával, azonban ez plusz egy változót kellene jelentsen. Ehelyett direkt módon próbáljuk meg felírni a kifejezést. Használhatnánk a NOT kapunál látott logikai negálást, azonban amíg ott az kifejezés értékkészlete is bináris volt, ezúttal a kifejezés akár a $3$-at is felveheti értékként. Ennek ellenére a NOR kapu kifejezése majdnem valóban az OR logikai negáltja lesz, csupán az $xy$ szorzat együtthatója változatlan marad.

\begin{allitas}
	Az $x \vee y = \neg z$ kvadratikus függvénye a 
	\begin{align}
	\begin{split}
		1-(x+y)-z+2(x+y)z+xy = \\
		 1-x-y-z+2xz+2yz+xy.
	\end{split}
	\end{align}	
	A helyességről ismét meggyőződhetünk az igazságtáblázat használatával.
\end{allitas}

\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c c c c }
		\toprule
		x & y & z & $f(x,y,z)$ \\
		\midrule
		0 & 0 & 0 & 1 \\
		0 & 0 & 1 & 0 \\
		0 & 1 & 0 & 0 \\
		0 & 1 & 1 & 1 \\
		1 & 0 & 0 & 0 \\
		1 & 0 & 1 & 1 \\
		1 & 1 & 0 & 0 \\
		1 & 1 & 1 & 3 \\		
		\bottomrule
	\end{tabular}
	\caption{NOR kapu}
	\label{tab:NORgate}
\end{table}

\subsubsection{XOR kapu ($x \oplus y = z$)} \label{sec:XORgate}

Ahogyan korábban ez előtérbe került a ,,két szám bináris felírása különböző-e" kérdéskör kapcsán \az+\refstruc{sec:QUBObinary+ban}, nagyon hasznos lenne egy KIZÁRÓ VAGY avagy XOR kapu is. Közismert, hogy csupán az AND és a NOT segítségével is felírható bármely Boole-függvény, így ezek tetszőleges kombinálásával természetesen a XOR is.
Ha megpróbáljuk direkt módon, csupán 3 változó segítségével felírni, problémába ütközünk, mivel ez nem lehetséges. Ezt a tényt mondja ki az alábbi tétel, melyet bizonyítok, és a bizonyítás módszer egyben megad egy általános módszert is hasonló problémák felírására.

\begin{theorem}
	\label{XORnotexist}
		Az $x \oplus y = z$ kifejezésnek nem létezik kvadratikus függvénye.
		
		Indirekt módon tegyük fel, hogy lehet megfelelő kifejezést alkotni. Legyen ez a kifejezés $f(x,y,z)=A_xx+A_yy+A_zz+A_{xy}xy+A_{xz}xz+A_{yz}yz+C$. Tudjuk, hogy az érvényes változókonfigurációk behelyettesítésére $0$-t, érvénytelen esetben pedig egy $0$-nál nagyobb pozitív számot kell kapjunk. 
		(Tekinthetnénk $0$ helyett egy másik fix számot, de a $C$ taghoz hozzáadva az eltolást ezt korrigálhatjuk, illetve ha minimalizálás helyett maximalizálni szeretnénk, akkor elég a kifejezést $-1$-gyel beszorozni.)
		
		Minden változókonfiguráció behelyettesítésével így kapunk egy egyenletet vagy egyenlőtlenséget, melyet az együtthatóknak és a konstans tagnak teljesítenie kell. Az igazságtáblázat 8 sorából keletkező egyenleteket és egyenlőtlenségeket az alábbi táblázat foglalja össze.
		
		\begin{table}[ht]
			\footnotesize
			\centering
			\begin{tabular}{ c c c c l }
				\toprule
				x & y & z & $f(x,y,z)$ & egyenlet/egyenlőtlenség \\
				\midrule
				0 & 0 & 0 & $0 $ & $C=0$   \\
				0 & 0 & 1 & $>0$ & $A_{z}+C>0$ \\
				0 & 1 & 0 & $>0$ & $A_{y}+C>0$ \\
				0 & 1 & 1 & $0 $ & $A_{y}+A_{z}+A_{yz}+C=0$   \\
				1 & 0 & 0 & $>0$ & $A_{x}+C>0$ \\
				1 & 0 & 1 & $0 $ & $A_{x}+A_{z}+A_{xz}+C=0$   \\
				1 & 1 & 0 & $0 $ & $A_{x}+A_{y}+A_{xy}+C=0$   \\
				1 & 1 & 1 & $>0$ & $A_{x}+A_{y}+A_{z}+A_{xy}+A_{xz}+A_{yz}+C>0$ \\				
				\bottomrule
			\end{tabular}
			\caption{XOR kapu 3 változóval}
			\label{tab:XORgate3var}
		\end{table}
		
		Az első egyenletből látjuk, hogy $C=0$, így a továbbiakban ezt mindenhova behelyettesíthetjük. A 4. 6. és 7. sorokból tudhatjuk, hogy $A_{yz}=-A_y-A_z$, $A_{xz}=-A_x-A_z$ és $A_{xy}=-A_x-A_y$. Ezeket behelyettesítve a 8. sorba, az azonos tagok összevonása után azt kapjuk, hogy $-A_x-A_y-A_z>0$.
		Azonban a 2. 3. és 5. sorokból azt tudjuk, hogy $A_x$, $A_y$ és $A_z$ pozitív számok. Tehát ellentettjeik összege csakis negatív lehet, nem pedig pozitív. Ez ellentmondás, tehát nem létezhet ilyen kifejezés sem, mellyel a bizonyítás teljes.	
\end{theorem}



Segédváltozók használatával azonban megoldható a probléma, például az alábbi módon. Elég egyetlen segédváltozót bevezetni, ráadásul ennek a változónak mellékesen szemantikusan is adhatunk értelmet, így mondhatjuk a $t$ segédváltozó jelentése legyen $x \wedge y$.
Ekkor a kifejezésünket megkonstruálhatjuk, hogy már a korábban látott módon megkötjük, hogy $t = x \wedge y$, az $xy-2(x+y)z+3z$ kifejezéssel, ezt a kifejezést aztán egy megfelelően nagy számmal beszorozzuk, hogy amikor a további együtthatókat határozzuk meg, biztosan ne romoljon majd el ez az összefüggés. $-2xy-2(x+y)t+(x+y)+t+4zt$ kifejezés minden esetben $0$-t ad a megfelelő konfigurációkra, és egy pozitív számot a helytelenekre, amennyiben csak azokat az eseteket nézzük, ahol $t = x \wedge  y$ teljesül. Amennyiben a feltétel nem adott, akár $-3$-at is kaphatunk eredményül. Ezért tehát a $t = x \wedge  y$-t kikényszerítő feltételt legalább 4-gyel meg kell szorozzuk, ezáltal a büntető tag értéke minden esetben nagyobb lesz $0$-nál, ha a konfiguráció helytelen. Tehát a végleges kifejezést a (\ref{XORQUBO}) írja le.



\begin{align}
\begin{split} \label{XORQUBO}
	4(xy-2(x+y)z+3z)+(-2xy-2(x+y)t+(x+y)+t+4zt) = \\
    = 4xy-8z(x+y)+12z-2xy-2(x+y)t+(x+y)+t+4zt = \\
	= (x+y)+t+12z+2xy-2(x+y)t+4zt-8z(x+y)	
\end{split}
\end{align}

\begin{table}[ht]
	\footnotesize
	\centering
	\begin{tabular}{ c c c c c }
		\toprule
		x & y & z & t & $f(x,y,z,t)$ \\
		\midrule
		0 & 0 & 0 & 0 & 0 \\
		0 & 0 & 0 & 1 & 12 \\
		0 & 0 & 1 & 0 & 1 \\
		0 & 0 & 1 & 1 & 17 \\
		0 & 1 & 0 & 0 & 1 \\
		0 & 1 & 0 & 1 & 5 \\
		0 & 1 & 1 & 0 & 0 \\
		0 & 1 & 1 & 1 & 8 \\		
		1 & 0 & 0 & 0 & 1 \\
		1 & 0 & 0 & 1 & 5 \\
		1 & 0 & 1 & 0 & 0 \\
		1 & 0 & 1 & 1 & 8 \\
		1 & 1 & 0 & 0 & 4 \\
		1 & 1 & 0 & 1 & 0 \\
		1 & 1 & 1 & 0 & 1 \\
		1 & 1 & 1 & 1 & 1 \\		
		\bottomrule
	\end{tabular}
	\caption{XOR kapu}
	\label{tab:XORgate}
\end{table}

Ezáltal minden alapvető logikai kaput le tudunk írni QUBO alakkal, és a XOR kapu 3 változóval történő felírásának bizonyításánál egy általános módszert is kaptunk további, összetettebb kapuk implementálására, amellett, hogy természetesen az alapszintű kapukból is megkonstruálhatunk tetszőleges kombinációs hálózatot.

\subsection{Összetett kapuk}

Összetett logikai kapuk közül most csak a több-bementű OR kaput fogom vizsgálni. Valószínűleg a legtöbb hasonló kapura, mint például a sokbemenetű AND kapura is, az alábbiak analóg módon átvihetők.

\subsubsection{Sokbemenetű OR kapu ($x \vee y \vee z = t$)} \label{sec:MORgate}

\Az+\refstruc{sec:QUBObinary+ban} részproblémaként került elő sokbemenetű OR kapu előállítása. Ekkor arra hivatkoztam, hogy ez csak több OR kapu kaszkádosításával érhető el. Az alább közlök egy, az előbb látotthoz hasonló bizonyítást, mely szerint nem létezhet QUBO alakban felírt 3 bemenetű OR kapu, segédváltozó használata nélkül.

\begin{theorem}
	\label{3ORnotexist}
		Az $x \vee y \vee z = t$ kifejezésnek nem létezik kvadratikus függvénye.
		
		Ismét tegyük fel indirekten, hogy létezik ilyen kifejezés, vagyis léteznek olyan együtthatók, melyre a $A_{x}x+A_{y}y+A_{y}y+A_{z}z+ A_{xy}xy+A_{xz}xz+A_{xt}xt+ A_{yz}yz+A_{yt}yt+A_{zt}zt+C$ kifejezés a $t=x \vee y \vee z$ logikai kapcsolat fennállása esetén $0$-t, ellenkező esetben valamilyen pozitív számot kapunk behelyettesítés után.
		
		Mivel $0=0 \vee 0 \vee 0$ igaz, ezért $C=0$, így a továbbiakban ezt a konstans tagot elhagyom.
		
		Érdemes ismét összegyűjteni az egyenleteinket és egyenlőtlenségeinket.
		
		\begin{table}[ht]
			\footnotesize
			\centering
			\begin{tabular}{ c c c c c l }
				\toprule
				x & y & z & t & $f(x,y,z,t)$ & egyenlet/egyenlőtlenség \\
				\midrule
				0 & 0 & 0 & 0 & $0 $ & $(C=0)$  \\
				0 & 0 & 0 & 1 & $>0$ & $A_{t}>0$ \\
				0 & 0 & 1 & 0 & $>0$ & $A_{z}>0$ \\
				0 & 0 & 1 & 1 & $0 $ & $A_{z}+A_{t}+A_{zt}=0$   \\
				0 & 1 & 0 & 0 & $>0$ & $A_{y}>0$ \\
				0 & 1 & 0 & 1 & $0 $ & $A_{y}+A_{t}+A_{yt}=0$   \\
				0 & 1 & 1 & 0 & $>0$ & $A_{y}+A_{z}+A_{yz}>0$   \\
				0 & 1 & 1 & 1 & $0 $ & $A_{y}+A_{z}+A_{t}+A_{yz}+A_{yt}+A_{zt}=0$ \\			
				1 & 0 & 0 & 0 & $>0$ & $A_{x}>0$   \\
				1 & 0 & 0 & 1 & $0 $ & $A_{x}+A_{t}+A_{xt}=0$ \\
				1 & 0 & 1 & 0 & $>0$ & $A_{x}+A_{z}+A_{xz}>0$ \\
				1 & 0 & 1 & 1 & $0 $ & $A_{x}+A_{z}+A_{t}+A_{xz}+A_{xt}+A_{zt}=0$   \\
				1 & 1 & 0 & 0 & $>0$ & $A_{x}+A_{y}+A_{xy}>0$ \\
				1 & 1 & 0 & 1 & $0 $ & $A_{x}+A_{y}+A_{t}+A_{xy}+A_{xt}+A_{yt}=0$   \\
				1 & 1 & 1 & 0 & $>0$ & $A_{x}+A_{y}+A_{z}+A_{xy}+A_{xz}+A_{yz}>0$   \\
				1 & 1 & 1 & 1 & $0 $ & $A_{x}+A_{y}+A_{z}+A_{t}+A_{xy}+A_{xz}+A_{yz}+A_{xt}+A_{yt}+A_{zt}=0$ \\	
				\bottomrule
			\end{tabular}
			\caption{3 bemenetű OR kapu segédváltozó nélkül}
			\label{tab:ORgate3in}
		\end{table}
		
		\Az+\refstruc{tab:ORgate3in+ban} a 4. és 6. sorban lévő egyenleteket kivonva a 8.-ból következik az $A_{yz}=A_{t}$ azonosság. Hasonlóan, szimmetria okok miatt is, a 4. 10. 12. egyenletekből következik $A_{xz}=A_{t}$ illetve 6. 10. 14. egyenletekből következik $A_{xy}=A_{t}$.
		
		Ezeket behelyettesítve a 16. egyenletbe $A_{x}+A_{y}+A_{z}+4A_{t}+A_{xt}+A_{yt}+A_{zt}=0$ adódik. Melyből kivonva a 4. 6. és 10. egyenleteket, $A_{t}=0$ következik. Ez persze ellentmondásba kerül a 2. egyenlőtlenséggel, tehát az indirekt feltevésünk hibás, vagyis valóban nem lehet segédváltozó nélkül 3 bemenetű OR kaput definiálni QUBO segítségével.	
\end{theorem}

Azt látjuk tehát, hogy 3 bit OR kapcsolatba állításához szükség van legalább 2 segédváltozóra, melyből egyik az eredmény. Ez el is érhető például úgy, hogy az első két bitre kiszámítjuk az OR értékét, majd az így kapott segédváltozóra és a 3. bitre újra alkalmazzuk az OR operátort, így megkapjuk az eredményt. Ez a stratégia természetesen folytatható $k$ darab változóra, így $k$ bemenetű OR mindig felírható $k-1$ segédváltozóval, melybe beleértendő az eredmény bit is. Ebből persze nem következik triviálisan, hogy ez az optimális, azaz $k$ darab bit OR kapcsolatba állításához mindig legalább további $k-1$ segédváltozóra van szükség, de hirtelen úgy tűnik, hogy ennél jobbat nem lehet csinálni.
